= Actors and async data
:proglang: Motoko
:company-id: DFINITY

{proglang} provides an *actor-based* programming model to developers to express _server behavior_, including that of _micro services_ on the Internet and the Internet Computer.

An actor is similar to an object, but is special in that its isolated state exists _remotely_, and its interactions with the world are _asynchronous_.

Each {proglang} actor represents a service that one might want to deploy on the Internet Computer.

The interface of each actor introduces `async` data whenever it returns information to its caller.
This programming abstraction serves a key role in {proglang}, as it coordinates with the transformations of the {proglang} compiler pipeline and eventual execution behavior of {proglang} actors on the Internet Computer.

This abstraction represents a _promise_ from the system to the caller, on behalf of the callee:

 - Either the `async` value, when ``await``ed, will yield a value from the callee of the expected type,

 - or, an error --- system-level or callee-level --- will eventually arise.

In general, the caller may not _immediately_ `await` each call.  But even in cases when they do, they use the same `async` and `await` abstractions, for the same reason: to maintain the illusion of call-return, direct-style control flow, as supported by the {proglang} compiler's transformations.

*Technical aside.* In reality, the underlying message-passing of the system forces the program's logic into another form.
Specifically, control flow around each actor method call involves the program loosing control to a system-level message-processing loop, which forces the program's logic into a so-called
_"continuation-passing-style"_ (CPS) to expose event-handling
_"callback functions"_.
This program structure is complex for humans to read and maintain, and stands in stark contrast to the direct style most prefer for most program logic.

We note that {proglang} programs may avoid callbacks for many cases, but not _all_ cases where they are used in other asynchronous, message-passing settings.
Notably, callbacks are still needed when they serve as a fundamental aspect of the service's interface, as with a link:sharing{outfilesuffix}[publish-subscribe] service, where users register with the service to get notified some times later, when some predetermined class of events, occur over time.


To start, we consider the simplest stateful service: a counter with
a single "current count" value.

== Example: a Counter service

Consider the following actor declaration:

[source,motoko]
----
include::../examples/Counters.mo[]
----

////
actor Counter {
  var count : Nat = 0;

  public func inc() : async () {
    count += 1;
  };

  public func get() : async Nat {
    count
  };

  public func set(n: Nat) : async () {
    count := n;
  };
}
////

The `Counter` actor declares one field and three public functions:

* the field `count` is mutable, intialized to zero and implicitly `private`.
* function `inc()` asynchronous increments the counter and returns a promise of type `async ()` for synchronization.
* function `get()` asynchronously reads the counter value and returns a promise of type `async Nat` containing its value.
* function `set(n)` asynchronously resets the counter's value using its argument `n` and returns a promise of type `async ()`.

The only way to read or modify the state (`count`) of the `Counter` actor is through its functions.

Because all interaction with actors is asynchronous, an actor's public functions must either
return a promise type `async T`, for some type `T`, or nothing at all `()`.

A value of type `async T` is a _promise_. The producer of the promise
fulfills the promise when it returns a result, either a value or error.

The only thing a consumer can do with a promise is wait for it to be fulfilled by the producer,
throw it away, or store it for later use.

== Using `await` to consume async promises

To access the result of an `async` value -a promise returned from an asynchronous call-
the receiver of the promise use an  `*await*` expression.

For example, to use the result of `Counter.get()` above, we can first bind the
promise to an identifier `a`, and then `await a` to retrieve the underlying `Nat`, `n`:

[source, motoko]
----
let a : async Nat = Counter.get();
let n : Nat = await a;
----

The first line immediately receives _a promise of the current value_, but does not wait for it, and thus cannot (yet) use it as a natural number.

The second line ``await``s this promise and extracts the result, a natural number.
This line may suspend execution until the promise has been fulfilled.

Typically, one rolls the two steps into one and one just awaits an asynchronous call directly:

[source, motoko]
----
let n : Nat = await Counter.get();
----

Unlike an ordinary function call, which blocks the caller until the callee has returned a result,
an asynchronous call immediately returns a promise, `p`, without blocking.
Instead of blocking, a later call to `await p` can suspend the current computation until or unless `p` is fullfilled.
Once the promise if fulfilled (by the producer), execution of `await p` resumes with its result.
If the result is a value, `await p` returns that value.
Otherwise the result is some error, and `await p` propagates the error to the
consumer of `await p`.

(Awaiting a promise a second time will just produce the same result.)

WARNING: A function that does not `await` in its body is guaranteed to
execute atomically - in particular, the environment cannot change the
state of the actor while the function is executing.  If a function
performs an `await`, however, atomicity is no longer guaranteed.  Between suspension
and resumption around the `await`, the state of the enclosing actor
may change due to concurrent processing of other incoming actor
messages. It is the programmer's responsibility to guard against
non-synchronized state changes.

== Query functions

In {IC} terminology, all three `Counter` functions are _update_ messages
than can alter the state of the canister when called and need to go
through consensus amongst the distributed replicas before the {IC} can
commit the state change and return a result.  Reaching concensus is an
expensive process with high latency.

For applications that don't
require the guarantees of concensus, the {IC} supports more efficient
_query_ operations. These are able to read the state of a canister from a single replica,
modify a snapshot during their execution and return a result, but
cannot permanently alter the state or send further {IC} messages.

Motoko supports the implementation of {IC} queries using `query` functions. The `query` keyword
modifies the declaration of a (shared) actor function so that it executes with non-committing, and faster,
{IC} query semantics.

For example, we can extend the `Counter` with fast-and-loose variant of the trustworthy `read` function, called `peek`:

[source,motoko]
----
include::../examples/CounterWithQuery.mo[]
----

The `peek()` function might be used by a `Counter` frontend offering a quick, but less trustworthy,
display of the current counter value.

It is a compile-time error for query a method to call an actor function  since this would violate dynamic restrictions
imposed by the {IC}. Calls to ordinary functions are permitted.

Query functions can be called from non-query functions. Because those nested calls require concensus,
the efficienty gains of nested query calls will be modest at best.


[#actor_classes]
== Actor classes generalize an actor's initial state

An actor _class_ generalizes a single actor declaration to the declaration of family of actors satisfying the same interface.
An actor class declares a type, naming the interface of its actors, and a function that
constructs a fresh actor of that type each time it is supplied with an argument.
An actor class thus serves as a template for manufacturing actors.
Because canister installation is asychronous on the {IC}, the constructor function is asynchronous too, and returns its actor in a promise.

For example, we can generalize `Counter` given above to `Counter(init)`
below, by introducing a constructor parameter, variable `init` of type `Nat`:

.Counters.mo
[source, motoko]
----
include::../examples/Counters.mo[]
----

If this is class is stored in file `+Counters.ml+`, then
we can import the file as a module and use it to
create several actors with different initial values:

[source, motoko]
----
import Counters "Counters";

let c1 = await Counters.Counter(1);
let c2 = await Counters.Counter(2);
----

The last two lines above _instantiate_ the actor class twice.
The first invocation uses the initial value `1`, where the second uses initial value `2`.
Because actor class instantiation is asynchronous, each call to `Counter(init)` returns a promise that can be ``await``ed for the resulting actor value.
Both `c1` and `c2` have the same type, `Counters.Counter` and can be used interchangeably.


NOTE: For now, the {proglang} compiler gives an error when compiling
programs that do not consist of a single actor or actor class.
Compiled programs may still, however, reference imported actor classes.
For more information, see link:modules-and-imports{outfilesuffix}#importing_actor_classes[Importing actor classes] and link:actor-classes{outfilesuffix}#actor_classes[Actor classes].

== Stable and flexible variables

To enable {proglang} to migrate the current state of variables when a canister is upgraded, you must identify those variables as containing data that must be preserved.

In an actor, you can identify a variable that must be preserved by using the _stable_ modifier as part of the variable's declaration.

More precisely, every `+let+` and `+var+` variable declaration in an actor must specify whether the variable is a `+stable+` variable or a `+flexible+` variable. If you don't include a modifier in the declaration, the variable is treated as a `+flexible+` variable by default.

Concretely, you use the following syntax to declare stable or flexible variables in an actor:

....
<dec-field> ::=
  (public|private)? (stable|flexible)? dec
....

Explicitly declaring whether a variable is `+stable+` or `+flexible+` ensures the appropriate type restrictions apply.
Note that you should only use the `+stable+` or `+flexible+` modifier on `let` and `var` declarations that are **actor fields**.
You should not use the `+stable+` or `+flexible+` modifier anywhere else in your program.

The representation for stable variable signatures looks like a {proglang} actor type:

....
actor {
  stable x : Nat;
  stable var y : Int;
  stable z : [var Nat];
};
....

=== Typing

Because the compiler must ensure that stable variables are both compatible with and meaningful in the replacement program after an upgrade, the following type restrictions apply to stable state:

* A `+stable+` declaration must have a _stable_ type.
* Stable types are a superset of _shared_ types.
* Stable types allow objects or arrays with mutable components.

The key point to note is that stable types extend shared types to include **mutable arrays and fields**.
Like shared types, stable types exclude ordinary functions and structures built from functions (such as objects).
This exclusion of functions and structures built from functions is required because the meaning of a function value—consisting of both data and code—cannot be preserved across an upgrade, while the meaning of plain data—mutable or not—can be preserved.

NOTE: In general, object types are not stable because they can contain local functions.
However, records are a special case because a record consists of fields that are stable with data that can be preserved across updates.
Actors and shared functions are also stable, allowing you to preserve their values across upgrades. For example, you can preserve values for a set of actors or callbacks subscribing to a service.

=== How stable variables are upgraded

When you first compile and deploy an actor (canister), all flexible and stable variable are initialized in sequence.
When you deploy an actor (canister) as an upgrade,  all stable variables that existed in the previous version are pre-initialized with their old values.
After the stable variables are initialized with their previous values, the remaining flexible and newly-added stable variables are initialized in sequence.


////
TODO: describe pre and post upgrade hooks
////
