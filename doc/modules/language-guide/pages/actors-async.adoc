= Actors and async data
:proglang: Motoko
:company-id: DFINITY

The programming model of the {IC} consists of memory-isolated canisters communicating by asynchronous message passing of unstructured, binary data. A canister processes its messages one-at-a-time, preventing race conditions.  A canister uses call-backs to register what needs to be done with the result of any inter-canister messages it issues.

{proglang} abstracts the complexity of the {IC} with a well known, higher-level abstraction: the _actor model_.
Each canister is represented as a typed actor. The type of an actor lists the messages
it can handle. Each message is abstracted as a typed, asynchronous function, imposing structure on the raw binary data of the underlying {IC}.
An actor is similar to an object, but is different in that its state is completely isolated,
its interactions with the world are entirely through asynchronous messaging, and its messages are processed one-at-a-time, even when issued in parallel by concurrent actors.

In {proglang}, sending a message to an actor is a function call, but instead of
blocking the caller until the call has returned, the message is enqueued
on the callee, and a promise representing that unfulfilled request
immediately returned to the caller.  The promise is a placeholder for the eventual result
of the request, that the caller can later query. Between issuing the
request, and deciding to wait for the result, the caller is free to do
other work, including issuing more requests to the same or other
actors.
Once the caller has processed the request, the promise is fulfilled and its result made
available to the callee.
If the callee is waiting on the promise, its execution can resume with the result, otherwise the result is simply stored in the promise for future examination.

In {proglang}, actors have dedicated syntax and types; messaging is handled by so called _shared_ functions returning promises (shared because they are available to remote actors);
a promise, `p`, is a value of the special type `async T` for some type `T`; waiting
on `p` to be fulfilled is expressed using `await p` to obtain a value of type `T`.
To avoid introducing shared state through messaging, e.g. by sending an object or mutable array,
the data that can be transmitted through shared functions is restricted to immutable, _shared_ types.

To start, we consider the simplest stateful service: a `Counter` actor, the distributed version of our previous, local `counter` object.

== Example: a Counter service

Consider the following actor declaration:

[source,motoko]
----
include::../examples/counter-actor.mo[]
----

////
actor Counter {

  var count = 0;

  public shared func inc() : async () { count += 1 };

  public shared func read() : async Nat { count };

  public shared func bump() : async Nat {
    count += 1;
    count;
  };
};
////

The `Counter` actor declares one field and three public, _shared_ functions:

* the field `count` is mutable, initialized to zero and implicitly `private`.
* function `inc()` asynchronously increments the counter and returns a promise of type `async ()` for synchronization.
* function `read()` asynchronously reads the counter value and returns a promise of type `async Nat` containing its value.
* function `bump()` asynchronously increments and reads the counter.

Shared functions, unlike local functions, are accessible to remote callers and have additional restrictions: their arguments and return value must be _shared_ types - a subset of types that includes immutable data, actor references, and shared function references, but excludes
references to local functions and mutable data. Because all interaction with actors is asynchronous,
an actor's functions must  return a promise type `async T`, for some type `T`.

The only way to read or modify the state (`count`) of the `Counter` actor is through its shared functions.

A value of type `async T` is a promise. The producer of the promise
fulfills the promise when it returns a result, either a value or error.

Unlike objects and modules, actors can only expose functions, and these functions must be `shared`. For this reason, {proglang} allows you to omit the `shared` modifier on public actor functions, allowing the more concise, but equivalent, actor declaration:

[source,motoko]
----
include::../examples/counter-actor-sugar.mo[]
----

For now, the only place shared functions can be declared is in the
body of an actor or actor class.  Despite this restriction, shared
functions are still first-class values in {proglang} and can be passed
as arguments or results, and stored in data structures.

The type of a shared functions is specified using a shared function type. For example, the
value `inc` has type `shared () -> async Nat` and could be supplied
as a standalone callback to some other service (see link:sharing{outfilesuffix}[publish-subscribe] for an example).

== Actor types

Just as objects have object types, actors have _actor types_. The
`Counter` actor has the following type:

....
actor {
  inc  : shared () -> async ();
  read : shared () -> async Nat;
  bump : shared () -> Nat;
}
....

Again, because the `shared` modifier is required on every member of an actor,
{proglang} both elides them on display, and allows you to omit them
when authoring an actor type.

Thus the previous type can be expressed more succinctly as:

....
actor {
  inc  : () -> async ();
  read : () -> async Nat;
  bump : () -> Nat;
}
....

Like object types, actor types support subtyping: an actor type is a subtype of a more general one that offers fewer functions with more general types.

== Using `await` to consume async promises

The caller of a shared function typically receives a promise, a value of type `async T` for some T.

The only thing the caller, a consumer, can do with this promise is
wait for it to be fulfilled by the producer, throw it away, or store
it for later use.

To access the result of an `async` value, the receiver of the promise use an  `*await*` expression.

For example, to use the result of `Counter.read()` above, we can first bind the
promise to an identifier `a`, and then `await a` to retrieve the underlying `Nat`, `n`:

[source, motoko]
----
let a : async Nat = Counter.read();
let n : Nat = await a;
----

The first line immediately receives _a promise of the current value_, but does not wait for it, and thus cannot (yet) use it as a natural number.

The second line ``await``s this promise and extracts the result, a natural number.
This line may suspend execution until the promise has been fulfilled.

Typically, one rolls the two steps into one and one just awaits an asynchronous call directly:

[source, motoko]
----
let n : Nat = await Counter.read();
----

Unlike a local function call, which blocks the caller until the callee has returned a result,
a shared function call immediately returns a promise, `p`, without blocking.
Instead of blocking, a later call to `await p` can suspend the current computation until or unless `p` is fulfilled.
Once the promise if fulfilled (by the producer), execution of `await p` resumes with its result.
If the result is a value, `await p` returns that value.
Otherwise the result is some error, and `await p` propagates the error to the
consumer of `await p`.

Awaiting a promise a second time will just produce the same result.

WARNING: A function that does not `await` in its body is guaranteed to
execute atomically - in particular, the environment cannot change the
state of the actor while the function is executing.  If a function
performs an `await`, however, atomicity is no longer guaranteed.  Between suspension
and resumption around the `await`, the state of the enclosing actor
may change due to concurrent processing of other incoming actor
messages. It is the programmer's responsibility to guard against
non-synchronized state changes.

For example, the implementation of `bump()` above is guaranteed to increment and read the
value of `count`, in one atomic step. The alternative implementation:

....
  public shared func bump() : async Nat {
    await inc();
    await read();
  };
....

does _not_ have the same semantics and allows another client of the actor to
interfere with its operation: each `await` suspends execution, allowing an interloper
to change the state of the actor.
By design, the explicit ``await``s make the potential points of interference clear to the reader.

== Query functions

In {IC} terminology, all three `Counter` functions are _update_ messages
than can alter the state of the canister when called. Effecting a state change requires
agreement amongst the distributed replicas before the {IC} can
commit the change and return a result. Reaching consensus is an
expensive process with relatively high latency.

For the parts of applications that don't require the guarantees of consensus, the {IC} supports more efficient
_query_ operations. These are able to read the state of a canister from a single replica,
modify a snapshot during their execution and return a result, but
cannot permanently alter the state or send further {IC} messages.

{proglang} supports the implementation of {IC} queries using `query` functions. The `query` keyword
modifies the declaration of a (shared) actor function so that it executes with non-committing, and faster,
{IC} query semantics.

For example, we can extend the `Counter` actor with a fast-and-loose variant of the trustworthy `read` function, called `peek`:

[source,motoko]
----
include::../examples/CounterWithQuery.mo[]
----

The `peek()` function might be used by a `Counter` frontend offering a quick, but less trustworthy,
display of the current counter value.

It is a compile-time error for a query method to call an actor function since this would violate dynamic restrictions imposed by the {IC}. Calls to ordinary functions are permitted.

Query functions can be called from non-query functions. Because those nested calls require consensus,
the efficiency gains of nested query calls will be modest at best.

The `query` modifier is reflected in the type of a query function:

....
  peek : shared query () -> async Nat
....

As before, in `query` declarations and actor types the `shared` keyword can be omitted.

== Messaging Restrictions

The {IC} places restrictions on when and how canisters are allowed to communicate. These restrictions are enforced dynamically on the {IC} but prevented statically in {proglang}, ruling out a class
of dynamic execution errors. Two examples are:

*  canister installation can execute code, but not send messages.
*  a canister query method cannot send messages.

These restrictions are surfaced in {proglang} as restrictions on the context in which certain
expressions can be used.

In {proglang}, an expression occurs in an _asynchronous context_ if
it appears in the body of an `async` expression, which may be the body of a (shared or local) function or a stand-alone expression.
The only exception are `query` functions, whose body is not considered to open an asynchronous context.

In {proglang} calling a shared function is an error unless the function is called in an asynchronouus context. In addition, calling a shared function from an actor class constructor is also an error.

The `await` construct is only allowed in an asynchronous context.

The `async` construct is only allowed in an asynchronous context.

It is only possible to `throw` or `try/catch` errors in an asynchronous context.
This is because structured error handling is supported for messaging errors only and,
like messaging itself, confined to asynchronous contexts.

These rules also mean that local functions cannot, in general, directly call shared functions or `await` promises. This limitation can sometimes be awkward:  we hope to extend the type system to be more permissive in future.

////
TODO: scoped awaits (if at all)
////


[#actor_classes]
== Actor classes generalize actors

An actor _class_ generalizes a single actor declaration to the declaration of family of actors satisfying the same interface.
An actor class declares a type, naming the interface of its actors, and a function that
constructs a fresh actor of that type each time it is supplied with an argument.
An actor class thus serves as a factory for manufacturing actors.
Because canister installation is asynchronous on the {IC}, the constructor function is asynchronous too, and returns its actor in a promise.

For example, we can generalize `Counter` given above to `Counter(init)`
below, by introducing a constructor parameter, variable `init` of type `Nat`:

.Counters.mo
[source, motoko]
----
include::../examples/Counters.mo[]
----

If this class is stored in file `+Counters.mo+`, then
we can import the file as a module and use it to
create several actors with different initial values:

[source, motoko]
----
import Counters "Counters";

let C1 = await Counters.Counter(1);
let C2 = await Counters.Counter(2);
----

The last two lines above _instantiate_ the actor class twice.
The first invocation uses the initial value `1`, where the second uses initial value `2`.
Because actor class instantiation is asynchronous, each call to `Counter(init)` returns a promise that can be ``await``ed for the resulting actor value.
Both `C1` and `C2` have the same type, `Counters.Counter` and can be used interchangeably.


NOTE: For now, the {proglang} compiler gives an error when compiling
programs that do not consist of a single actor or actor class.
Compiled programs may still, however, reference imported actor classes.
For more information, see link:modules-and-imports{outfilesuffix}#importing_actor_classes[Importing actor classes] and link:actor-classes{outfilesuffix}#actor_classes[Actor classes].
