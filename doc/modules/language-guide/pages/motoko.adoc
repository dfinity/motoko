= Motoko Programming Language
:page-layout: default
:proglang: Motoko
:platform: Internet Computer blockchain network
:IC: Internet Computer
:ext: .mo
:company-id: DFINITY
:sdk-short-name: DFINITY Canister SDK
:sdk-long-name: DFINITY Canister Software Development Kit (SDK)
ifdef::env-github,env-browser[:outfilesuffix:.adoc]

[IMPORTANT]
=====================================================================
The {proglang} programming language continues to evolve with each release of the {sdk-short-name} and with ongoing updates to the {proglang} compiler. 
Check back regularly to try new features and see what's changed.
=====================================================================

The {proglang} programming language is a new, modern, type-sound language designed for developers who want to build the next generation of apps and services to run directly on the internet.
{proglang} is specifically designed to support the unique features of the Internet Computer and to provide a familiar yet robust programming environment.
As a new language {proglang} is constantly evolving with support for new features and improvements.

The {proglang} compiler, documentation and other tooling is https://github.com/dfinity/motoko[open source] and released under the Apache 2.0 license. Contributions are welcome.

[.cards.cards-4.personas.conceal-title]
{empty}

[.card]
== Native canister support

{proglang} has native support for Internet Computer software canisters, which are expressed as actors, autonomous objects that encapsulate their state and communicate through asynchronous messages.

[source#counter,motoko]
----
include::../examples/Counter.mo[]
----

[.card]
== Code sequentially in direct style

On the Internet Computer, software canisters call into other canisters asynchronously, but {proglang} enables you to program your systems sequentially in direct style. Asynchronous messages are function calls that return a future, and the await constructs allows chaining calls as if they were synchronous.

[source.include_counter,motoko]
----
include::../examples/factorial.mo[lines=9..-1]
----


[.card]
== Modern type system

{proglang} has been designed to be intuitive to those familiar with JavaScript and other popular languages, but offers modern features such as sound structural types, generics, variant types, and checked pattern matching.

[source,motoko]
----
include::../examples/tree.mo[]
----

[.card]
== Autogenerated IDL files

The SDK exports your interface definition in a language neutral format called `+Candid+`, so other canisters, browser resident code and smart phone apps that have permission can call into your functions. The {proglang} compiler can also read and write interface definition files, allowing {proglang} to seamlessly interact with canisters programmed in other languages.

For example, the previous `+Counter+` actor produces the following `+Candid+` IDL:

[source,candid]
....
service Counter : {
  inc : () -> (nat);
}
....

[.card]
== Orthogonal persistence

The Internet Computer persists the memory pages in which your canister runs. Thus the state of an actor and all its memory data structures survive indefinitely, they do not need to be “saved” explicitly.

For example, in the following Registry service, that assigns sequential IDs to textual names, the state of the hash table is preserved across calls, even though the state of the canister
is replicated across many nodes, and typically not resident in memory.

[source,motoko]
----
include::../examples/Registry.mo[]
----

[.card]
== Upgrades

{proglang} provides numerous features to help you leverage orthogonal persistence, including language features that allow your heap to self-migrate when you upgrade the software of a canister.

For example, {proglang} lets you declare certain variables as `stable`. The values of `stable` variables are automatically preserved across software upgrades.

Consider a stable counter:

[source,motoko]
----
include::../examples/StableCounter.mo[]
----

It can be installed, incremented _n_ times, and then upgraded, without interruption, to, for example, the richer implementation:

[source,motoko]
----
include::../examples/StableCounterUpgrade.mo[]
----

Because `+value+` was declared `stable`, the current state, _n_, of the service is retained after the upgrade. Counting will continue from _n_, not restart
from `0`.

Because the new interface is compatible with the previous one, existing clients referencing the service will continue to work, but new clients will be able to exploit its upgraded functionality
(the additional `reset` function).

For scenarios that can't be solved using stable variables alone, {proglang} provides user-definable upgrade hooks that run immediately before and after upgrade,
and allow you to migrate arbitrary state to stable variables.


[.card]
== And more ...

{proglang} provides many other developer productivity features, including subtyping, arbitrary precision arithmetic and garbage collection.

{proglang} is not, and is not intended to be, the only language for implementing canisters.
If it doesn't suit your needs, we are also working on adding Rust support to the SDK.
Our goal is to enable any language (with a compiler that targets WebAssembly) to be able to produce canisters that run on the {IC} and interoperate
with other, perhaps foreign, canisters through language neutral Candid interfaces.

Its tailored design means {proglang} should be the easiest and safest language for coding on the {IC}, at least for the forseeable future.

