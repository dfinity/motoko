# The StableMemory Library

Motoko stable variables, while convenient to use, require serialization
and deserialization of all stable variables on upgrade  (see link:upgrades{outfilesuffix}[Stable variables and upgrade methods]).  During an
upgrade, the current values of stable variables are first saved to IC
stable memory, then restored from stable memory after the new code is
installed.  Unfortunately, this mechanism does not scale to canisters
that maintain _large_ amounts of data in stable variables: there may
not be enough cycle budget to store then restore all stable variables
within an upgrade, resulting in failed upgrades.

To avoid this upgrade hazard, actors can elect to use a lower-level
`StableMemory` library.  The library allows the
programmer to incrementally allocate pages of IC stable memory and use
those pages to incrementally read and write data in a user-defined binary format.

The Motoko runtime system ensures there is no interference between the
abstraction presented by the `StableMemory` library and an actor's stable
variables, even though the two abstractions ultimately use the same underlying
(concrete) stable memory facilities available to all IC canisters.
This runtime support means that is safe for a Motoko program to
exploit both stable variables and `StableMemory`, within the same
application.

## The Library


Support for stable memory is provided by the link:../base-libraries/StableMemory{outfilesuffix}[StableMemory]
library in package `+base+`.


The interface to the `StableMemory` library consists of functions for querying and growing the currently allocated set of stable memory pages,
plus matching pairs of `load`, `store` operations
for most of Motoko's fixed-size scalar types.

More general `loadBlob` and `storeBlob` operations are also available for reading/writing binary blobs and other types that can be encoded as ``Blob``s (e.g. `Text` values) of arbitrary sizes, using Motoko supplied or user-provided encoders and decoders.

[source.no-repl,motoko]
----
module {

  /// Current size of the stable memory, in pages.
  /// Each page is 64KiB (65536 bytes).
  /// Initially `0`.
  size : () -> (pages : Nat32);

  /// Grow current `size` of stable memory by `pagecount` pages.
  /// Each page is 64KiB (65536 bytes).
  /// Returns previous `size` when able to grow.
  /// Returns `0xFFFF` if remaining pages insufficient.
  grow : (new_pages : Nat32) -> (oldpages : Nat32);

  loadNat8 : (offset : Nat32) -> Nat8;
  storeNat8 : (offset : Nat32, value: Nat8) -> ();

  /// ... and similar for Nat16, Nat32, Nat64,
  /// Int8, Int16, Int32 and Int64 ...

  loadFloat : (offset : Nat32) -> Float;
  storeFloat : (offset : Nat32, value : Float) -> ();

  /// Load `size` bytes starting from `offset` as a `Blob`.
  /// Traps on out-of-bounds access.
  loadBlob : (offset : Nat32, size : Nat) -> Blob;

  /// Write bytes of `blob` beginning at `offset`.
  /// Traps on out-of-bounds access.
  storeBlob : (offset : Nat32, value : Blob) -> ()

}
----

## Example

To demonstrate the `StableMemory` library, we present a dead simple
implementation of a logging actor that records text messages
in a scalable, persistent log.

The example illustrates the simultaneous use of
stable variables and stable memory.
It uses a single stable variable to keep track of the next available offset,
but stores the contents of the log directly in stable memory.

[source#StableLog.no-repl,motoko]
----
include::../examples/StableLog.mo[]
----

The auxilliary function `ensure(offset)` is
used to grow `StableMemory` as necessary to accommodate more data.
It computes the 64KiB page of a given offset and ensures enough pages have
been allocated to guarantee that offset is within bounds.

The shared `log` function allocates the next offset at which to store
its text argument, encodes the text argument as a blob and writes both
the size of the blob and contents of the blob at the next available
offset in StableMemory.

The shared `read` query reads the message at the given offset,
returning `null` if reading beyond the end of the log, or the `Text`
message and next `offset` to continue reading from. An initial read
should pass `0` as the first offset; a subsequent read should use the offset
returned from the previous one, as a simple form of cursor.  (This
overly simple implementation of `read` relies on the user providing
valid offsets and may trap or return garbage entries when abused.)

Because `StableLog` allocates and maintains its (potentially large)
log data directly in stable memory and uses just a small and fixed
amount of storage for actual stable variables (here `base`), upgrading
`StableLog` to a new implementation (perhaps to provide more
functionality) should not consume too many cycles, regardless of the
current size of the log.
