= Pattern matching
:proglang: Motoko
:company-id: DFINITY

Pattern matching is a language feature that makes it easy to both test and decompose structured data into its constituent parts. While most programming languages provide familiar ways to build up structured data, using pattern matching one takes apart structured data and brings into scope its fragments by binding them to the given names. Syntactically the patterns resemble the construction of structured data, but generally appear in input-direction positions, such as in function argument positions, after the `case` keyword in `switch` expressions, and after `let` (as well as `var`) declarations.

Consider the following function call:
```
let name : Text = fullName({ first = "Jane"; mid = "M"; last = "Doe" });
```
We see that an object with three fields is being built, then passed to the function `fullName`, and the returned result is being captured and brought into scope by the binding as `name`. The latter step is refered to as pattern matching, and `name : Text` is a pattern. When we consider the callee, we'll encounter something like
```
func fullName({ first : Text; mid : Text; last : Text }) : Text {
  ...
};
```
The input is an (anonymous) object, which is deconstructed into its three `Text` fields, whose values are bound to the identifiers `first`, `mid` and `last`. They can be freely used in the block that forms the body of the function. Above we have resorted to _name punning_ for object field patterns, their general form allows the binding identifier be distinct from the field name, as in `mid = middle_name : Text`.

A special role comes to _literal patterns_, which look just like literal constants. They are especially useful in `switch` expressions, since they can cause the current pattern match to _fail_, and thus commencing to match the next pattern. For example
```
switch ("Adrienne", #female) {
  case (name, #female) { "It's a girl! " # name };
  case (name, _) { name # ", a boy!" };
}
```
will match the first `case` clause (because binding to the identifier `name` cannot fail and the shorthand variant literal `#Female` compares as equal), and evaluate to `"It's a girl! Adrienne"`. The second clause showcases the _wildcard_ pattern `_`. It cannot fail, but won't bind any identifier.

The last kind of pattern are the `or`-patterns. As their name suggests these are two or more patterns that are separated by the keyword `or`. Each of the sub-patterns must bind the same set of identifiers, and is matched from left-to-right. An `or`-pattern fails when its rightmost sub-pattern fails.

.The following table summarises the different ways of pattern matching for an overview
|===
|pattern kind |examples |appears in |can fail |remarks

|literal
|`null`, `42`, `()`, `"Hi"`
|everywhere
|when the type has more than one value
|

|named
|`age`, `x`
|everywhere
|no
|introduces identifiers into a new scope

|wildcard
|`_`
|everywhere
|no
|

|typed
|`age : Nat`
|everywhere
|depends
|

|option
|`?0`, `?val`
|everywhere
|yes
|

| tuple
|`( component~0~, component~1~, ... )`
|everywhere
|depends
|must have at least two components

| object
|`{ field~A~; field~B~; ... }`
|everywhere
|depends
|allowed to mention a subset of fields

| field
|`age`, `count = 0`
|object
|depends
|`age` is short for `age = age`

|variant
|`#celsius deg`, `#sunday`
|everywhere
|yes
|`#sunday` is short form for `#sunday ()`

|alternative (`or`-pattern)
|`0 or 1`
|everywhere
|depends
| no alternative may bind an identifier
|===


== Trivia about patterns

Since pattern matching has a rich history and interesting mechanics, a few additional comments are justified.

- nomenclature
The (usually structured) expression that is being matched is frequently called the _scrutinee_ and the patterns appearing behind the keyword `case` are the _alternatives_. When every possible scutinee is matched by (at least one) alternative, then we say that the scrutinee is _covered_. The patterns are tried in top-down fashion and thus in case of _overlapping_ patterns the one higher-up is selected. A scrutinee is considered _dead_ (or _inactive_), if for every value that it matches there is higher-up alternative that is also matched.

- booleans
The data type `Bool` can be regarded as two disjoint altenatives (`true` and `false`) and Motoko's built-in `if` construct will _eliminate_ the data and turn it into _control_ flow. `if` expressions are a form of pattern matching that abbreviates the general `switch` expression for the special case of boolean scrutinees.

- variant patterns
  Motoko's variant types are a form of _disjoint union_ (sometimes also called a _sum type_). A value of variant type always has exactly one _discriminator_ and a payload which can vary from discriminator to discriminator. When matching a variant pattern with a variant value, the discriminators must be the same (in order to select the alternative) and if so, the payload gets exposed for further matching.

- enumerated types
Other programming languages (e.g. C, but not Motoko) often use a keyword `enum` to introduce enumerations. These are impoverished relatives of Motoko's variant types, as the alternatives are not allowed to carry any payload. Correspondingly in those languages the `switch`-like statements lack the full power of pattern matching. Motoko provides the short-hand syntax (as in `type Weekday = { #mon; #tue; ... }`) to define enumerations, where payload for the variants is not desired.

- error handling
Error handling can be considered a use-case for pattern matching

- non-failable matching
singleton types

- exhaustiveness (coverage) checking
 -- warns non-covered scrutinees (Motoko tries to come up with an example of a scrutinee that is not patched). The warning points out the danger that the program may trap
 -- warns dead alternatives

Errors and optional results that are discussed in xref:errors-and-options{outfilesuffix}[Errors and optional results] represent two specific types of pattern matching.
However, there are many other ways you can use pattern matching in {proglang} programs.
This section highlights other examples of pattern matching.

 - point: unhandled errors are a special case of non-exhaustive pattern match (for results and option types)
 - point: null-pointer errors are a special case of non-exhaustive pattern match
 - the {proglang} type checker statically enforces exhaustive pattern matches for all optional types (and variants); hence, null-pointer errors are ruled out statically, and are impossible dynamically.
