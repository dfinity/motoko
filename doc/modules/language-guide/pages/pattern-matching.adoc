= Pattern matching
:proglang: Motoko
:company-id: DFINITY

Pattern matching is a way to deal with data that is inverse of the well known _construction from smaller parts_: it takes apart structured data and brings into scope its parts by binding them to the given names. Syntactically the patterns resemble the construction of structured data, but generally appear in input-direction positions, such as in function argument positions, after the `case` keyword in `switch` expressions, and after `let` (as well as `var`) declarations.

Consider the following function call:
```
let name : Text = fullName({ first = "Jane"; mid = "M"; last = "Doe" });
```
We see that an object with three fields is being built, then passed to the function `fullName`, and the returned result is being captured and brought into scope by the binding as `name`. The latter step is refered to as pattern matching, and `name : Text` is a pattern. When we consider the callee, we'll encounter something like
```
func fullName({ first : Text; mid : Text; last : Text }) : Text {
  ...
};
```
The input is an (anonymous) object, which is deconstructed and its three `Text` fields are bound to the identifiers `first`, `mid` and `last`. They can be freely used in the block that forms the body of the function. Above we have resorted to _name punning_ for object field patterns, their general form allows the binding indentifier be distinct from the field name, as in `mid = middle_name : Text`.

A special role comes to _literal patterns_, which look just like literal constants. They are especially useful in `switch` expressions, since they can cause the current pattern match to _fail_, and thus commencing to match the next pattern. For example
```
switch ("Adrienne", #Female) {
  case (name, #Female) { "It's a girl! " # name };
  case (name, _) { name # ", a boy!" };
}
```
will match the first `case` clause (because binding to the identifier `name` cannot fail and the shorthand variant literal `#Female` compares as equal), and evaluate to `"It's a girl! Adrienne"`. The second clause showcases the _wildcard_ pattern `_`. It cannot fail, but won't bind any identifier.

The last kind of pattern are the `or`-patterns. As their name suggests these are two or more patterns that are separated by the keyword `or`. Each of the sub-patterns must bind the same set of identifiers, and is matched from left-to-right. An `or`-pattern fails when its rightmost sub-pattern fails.

.The following table summarises the different ways of pattern matching for an overview
|===
|pattern kind |examples |appears in |can fail |remarks

|literal
|`null`, `42`, `()`, `"Hi"`
|everywhere
|yes
|

|named
|`age`, `x`
|everywhere
|no
|introduces identifiers into a new scope

|wildcard
|`_`
|everywhere
|no
|

|typed
|`age : Nat`
|everywhere
|depends
|

|option
|`?0`, `?val`
|everywhere
|yes
|

| tuple
|`( component~0~, component~1~, ... )`
|everywhere
|depends
|must have at least two components

| object
|`{ field~A~; field~B~; ... }`
|everywhere
|depends
|allowed to mention a subset of fields

| field
|`age`, `count = 0`
|object
|depends
|`age` is short for `age = age`

|variant
|`#celsius deg`, `#sunday`
|everywhere
|yes
|`#sunday` is short form for `#sunday ()`

|alternative (`or`-pattern)
|`0 or 1`
|everywhere
|depends
|all alternatives must bind same set of names
|===

Errors and optional results that are discussed in xref:errors-and-options{outfilesuffix}[Errors and optional results] represent two specific types of pattern matching.
However, there are many other ways you can use pattern matching in {proglang} programs.
This section highlights other examples of pattern matching.

 - point: unhandled errors are a special case of non-exhaustive pattern match (for results and option types)
 - point: null-pointer errors are a special case of non-exhaustive pattern match
 - the {proglang} type checker statically enforces exhaustive pattern matches for all optional types (and variants); hence, null-pointer errors are ruled out statically, and are impossible dynamically.
