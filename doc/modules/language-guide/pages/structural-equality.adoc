= Structural Equality

(In)Equality is structural. It is defined only on `shared` types.
Informally this means equality is defined on types that don't contain mutable fields, mutable arrays, non-shared functions or components of generic type.

For example we can compare arrays of objects.
===
> let a = [ { x = 10 }, { x = 20 } ];
> let b = [ { x = 10 }, { x = 20 } ];
> a == b;
true : Bool
===
Importantly this does _not_ compare by reference, but by value.

== Subtyping
Equality respects subtyping so `{ x = 10 } == { x = 10; y = 20 }` returns `true`.
The compiler will warn in cases where this might lead to subtle unwanted behaviour.
For example: `{ x = 10 } == { y = 20 }` will return `true` because the two values get compared at the empty record type.
That's unlikely the intention, so the compiler will emit a warning here.

===
> { x = 10 } == { y = 20 };
stdin:1.1-1.25: warning, comparing incompatible types
  {x : Nat}
and
  {y : Nat}
at common supertype
  {}
true : Bool
===

== Generic types
It is not possible to declare that a generic type variable is `shared`, so equality can only be used on non-generic types. For example:

===
func eq<A>(a : A, b : A) : Bool = a == b;
===

Warns with:

===
stdin:1.35-1.41: warning, comparing abstract type
  A/9
to itself at supertype
  Any
===

Comparing these two at the `Any` type means this comparison will return `true` no matter its arguments, so this doesn't work as one might hope.

If you run into this limitation in your code, you should accept a comparison function of type `(A, A) -> Bool` as an argument, and use that to compare these values instead.
