[#actor_classes]
== Actor Classes

The ability to define and import actor classes allows one to create networks of actors programmatically.

As a toy example, we show how to implemented a distributed map from a space of keys, here  ``Nat``, to values, here ``Text``.

Our map supports simple insert and lookup operations.

To distribute our data, the space of keys is partioned into `+n+` subspaces. For now, we just fix ``n = 8``.
The subspace, `+i+`, of a key, `+k+`, is determined by the remainder of `k` divided by `n`, that is, `i = k % n`.
The ``i``th subspace (`+i+` in ``[0..n)``)  receives a dedicated actor to store text values assigned to keys in that subspace.

The actor responsible for space `+i+` is obtained as an instance of the actor class `+Node(i)+`, defined (in file ``Node.mo``) as follows:

```
actor class Node(i : Nat) {

  type Key = Nat;
  type Value = Text;

  var map = func (k: Nat) : ?Value { return null };

  public func lookup(k : Key) : async ?Value {
    return map(k);
  };

  public func insert(k : Key, v : Value) : async () {
    let map0 = map;
    map := func(k1 : Nat) : ?Value { if (k1 == k) ?v else map0(k1); };
  };

};
```

A node stores the current mapping of keys to values in a (mutable) `+map+` variable containing a function that initially assigns all keys to `+null+`.

On `+lookup(k)+`, the map actor simply returns any value stored at `+map(k)+`.

On `+insert(k, v)+` the map actor updates the current `+map+` function to a new function that maps `+k+` to `+?v+` and all other keys to their previous mapping.

Although this code makes no use of the class parameter `+i+`, it could be employed for logging, or (given `+n+`) asserting that keys are in an appropriate subspace (e.g. ``assert ((k % n) == i)``).

Clients of the map communicate with a coordinating `+Map+` actor:

```
import Array "mo:base/Array";
import Lib "Node";

actor Map {

  let n = 8; // number of nodes

  type Key = Nat;
  type Value = Text;

  type Node = Lib.Node;

  let nodes : [var ?Node] = Array.init(n, null);

  public func lookup(k : Key) : async ?Value {
    switch (nodes[k % n]) {
      case null null;
      case (?node) await node.lookup(k);
    };
  };

  public func insert(k : Key, v : Value) : async () {
    let i = k % n;
    let node = switch (nodes[i]) {
      case null {
        let n = await Lib.Node(i); // dynamically install a new Node
        nodes[i] := ?n;
        n;
      };
      case (?node) node;
    };
    await node.insert(k, v);
  };

};
```

The `+Map+` code imports the `+Node+` actor class as module `+Lib+`.

The actor maintains an array of `+n+` allocated nodes, with all
entries initially `null`. Entries are populated with `+Node+` actors
on demand.

On `+lookup(k, v)+`, the `Map` actor examines the key, `+k+`, divides it by
`+n+` and takes the remainder, `+i+`, to determine which of the `+n+` nodes
is responsible for storing the result.  If no such node exists yet, it
returns `+null+`, otherwise it delegates to that node by calling
`+node.lookup(k, v)+`.

On `+insert(k, v)+`, the `+Map+` actor again uses the remainder of `+k+`
divided `+n+`, to determine the index `+i+` of the node responsible for
storing the result.
If no such node exists, it first installs one
using an asynchronous call to the constructor, `+Lib.Node(i)+`, and, after awaitng the result, records it in the array `+nodes+`.
It then delegates the insertion to that node by calling `+node.insert(k, v)+`.

While our example fixes the number of nodes to `+8+`, we can easily
generalize the example by making the `+Map+` actor an actor class, adding a parameter `+(n : Nat)+` and omitting the declaration `+let n = 8;+`:

```
actor class MapClass(n : Nat) {

  type Key = Nat
  ...
}
```

Clients of `+MapClass+` are now free to determine the (maximum) number of nodes in the network by passing an argument on construction.

