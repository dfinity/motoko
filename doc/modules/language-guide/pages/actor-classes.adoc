[#actor_classes]
== Actor classes

Actor classes enable you to create networks of actors programmatically. 
To illustrate how to define and import actor classes, the following example implements a distributed map of keys of  type `Nat` that map to values of type `Text` and provides simple insert and lookup functions for working with these keys and values.



To distribute the data for this example, the space of keys is partitioned into `+n+` subspaces. For now, we just fix ``n = 8``.
The subspace, `+i+`, of a key, `+k+`, is determined by the remainder of `k` divided by `n`, that is, `i = k % n`.
The ``i``th subspace (`+i+` in ``[0..n)``)  receives a dedicated actor to store text values assigned to keys in that subspace.

The actor responsible for space `+i+` is obtained as an instance of the actor class `+Node(i)+`, defined in file `+Node.mo+` as follows:

```
actor class Node(i : Nat) {

  type Key = Nat;
  type Value = Text;

  var map = func (k: Nat) : ?Value { return null };

  public func lookup(k : Key) : async ?Value {
    return map(k);
  };

  public func insert(k : Key, v : Value) : async () {
    let map0 = map;
    map := func(k1 : Nat) : ?Value { if (k1 == k) ?v else map0(k1); };
  };

};
```

A node stores the current mapping of keys to values in a mutable `+map+` variable containing a function that initially assigns all key values to `+null+`.

On `+lookup(k)+`, the map actor simply returns any value stored at `+map(k)+`.

On `+insert(k, v)+` the map actor updates the current `+map+` function to a new function that maps `+k+` to `+?v+` and all other keys to their previous mapping.

Although this code makes no use of the class parameter `+i+`, it could be employed for logging, or (given `+n+`) asserting that keys are in an appropriate subspace (for example, `+assert ((k % n) == i)+`).

Clients of the map can then communicate with a coordinating `+Map+` actor like this:

```
import Array "mo:base/Array";
import Lib "Node";

actor Map {

  let n = 8; // number of nodes

  type Key = Nat;
  type Value = Text;

  type Node = Lib.Node;

  let nodes : [var ?Node] = Array.init(n, null);

  public func lookup(k : Key) : async ?Value {
    switch (nodes[k % n]) {
      case null null;
      case (?node) await node.lookup(k);
    };
  };

  public func insert(k : Key, v : Value) : async () {
    let i = k % n;
    let node = switch (nodes[i]) {
      case null {
        let n = await Lib.Node(i); // dynamically install a new Node
        nodes[i] := ?n;
        n;
      };
      case (?node) node;
    };
    await node.insert(k, v);
  };

};
```

As this example illustrates, the `+Map+` code imports the `+Node+` actor class as module `+Lib+`.

The actor maintains an array of `+n+` allocated nodes, with all
entries initially `null`. Entries are populated with `+Node+` actors
on demand.


On `+lookup(k, v)+`, the `Map` actor:

- examines the key, `+k+` and divides it by `+n+` 
- takes the remainder, `+i+`, to determine which of the `+n+` nodes
is responsible for the key
- returns`+null+` if the `+i+`th node does not exist, or
- delegates to that node by calling `+node.lookup(k, v)+` if it does.

On `+insert(k, v)+`, the `+Map+` actor:
- uses the remainder of key  `+k+`divided by `+n+` to determine the index `+i+` of the node responsible for that key
- installs node +i+ if the node does not exist by using an asynchronous call to the constructor, `+Lib.Node(i)+`, and, after awaiting the result, records it in the array `+nodes+`
- delegates the insertion to that node by calling `+node.insert(k, v)+`.

divided `+n+`, to determine the index `+i+` of the node responsible for
storing the result.
If no such node exists, it first installs one
using an asynchronous call to the constructor, `+Lib.Node(i)+`, and, after awaitng the result, records it in the array `+nodes+`.
It then delegates the insertion to that node by calling `+node.insert(k, v)+`.

While this example sets the number of nodes to `+8+`, you can easily
generalize the example by making the `+Map+` actor an actor class, adding a parameter `+(n : Nat)+` and omitting the declaration `+let n = 8;+`. For example:

```
actor class MapClass(n : Nat) {

  type Key = Nat
  ...
}
```

Clients of `+MapClass+` actor class are now free to determine the (maximum) number of nodes in the network by passing an argument on construction.
