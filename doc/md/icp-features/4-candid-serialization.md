---
sidebar_position: 4
---

# Candid serialization

[Candid](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/candid-concepts) is an interface description language and serialization format developed specifically for the Internet Computer. It provides a [language-agnostic](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid) way to describe and transmit data, enabling seamless communication between services and canisters regardless of their underlying programming languages. Leveraging [strong typing](https://internetcomputer.org/docs/references/candid-ref), Candid ensures precise and consistent data interpretation across different platforms and languages.

Candid encodes data using an efficient binary format optimized for network transmission. When one canister calls another, the arguments are serialized into Candid format, transmitted, and then deserialized by the receiving canister. This standardization empowers developers to build frontends in languages like JavaScript that effortlessly interact with backend canisters written in Motoko or other languages.

Additionally, Candid's design supports backward-compatible upgrades of canister interfaces, enabling services to evolve and improve over time without breaking existing integrations.

Motoko provides built-in functions for easy serialization and deserialization of data to and from Candid.

## Autogenerated Candid interfaces

When Motoko code is compiled, a Candid interface file [(`.did`)](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid#the-did-file) for the canister's public methods is automatically generated. This file is used to ensure data passed into and returned from these methods is automatically encoded to and decoded from Candidâ€™s binary format.

Motoko canisters automatically handle the serialization and deserialization of data when the canister interacts with [inter-canister calls or ingress messages](https://internetcomputer.org/docs/building-apps/essentials/message-execution).

## Candid functions

Motoko provides the `to_candid` and `from_candid` functions for serializing and deserializing Candid-encoded data.

It's important to note that there are many valid Candid encodings, and therefore many different `Blob` representations, for the same value. As a result, `to_candid` does not guarantee that the same input will always produce the same `Blob`. You should never use the output of `to_candid` to compare values for equality or to compute hashes.

In most cases, explicit serialization using `to_candid` and `from_candid` is unnecessary during regular development. These functions are typically reserved for advanced scenarios, such as:

- Making dynamic calls to arbitrary canisters.

- Handling raw binary data for storage or transmission.

- Managing stable data formats during canister upgrades.

For most common interactions, Candid serialization is handled automatically by the Motoko compiler.

### `to_candid`

The `to_candid` serializes Motoko values into a Candid-encoded binary `Blob`. This is useful when explicitly encoding data for storage, transmission between canisters, or dynamic inter-canister calls. The `to_candid` function can accept one or multiple arguments separated by commas.

```motoko no-repl
let encoding =  to_candid(true, "hello", 68, -90) // (Bool, Text, Nat, Int)
```

Each argument must be composed of sharable types. The resulting `Blob` precisely represents the original Motoko values according to Candid specifications.

```motoko no-repl
import Debug "mo:base/Debug";

actor {
  public type User = {
    userId : Nat;
    name : Text;
  };
  
  public func serializeUser(user : User) : async Blob {
    let encodedData : Blob = to_candid(user);
    Debug.print("User data serialized successfully.");
    encodedData;
  };
}
```

### `from_candid`

The `from_candid` function deserializes a Candid-encoded binary `Blob` back into Motoko values. This explicit decoding is useful in scenarios where serialized data needs to be processed or restored, such as reading from stable storage or handling dynamic input.

To decode a `Blob` correctly, `from_candid` requires an explicit type annotation or a clear type context. The result is returned as an optional (`?`) value, allowing you to safely handle potential failures caused by type mismatches or malformed data.

```motoko no-repl
import Debug "mo:base/Debug";

actor {
  public type User = {
    userId : Nat;
    name : Text;
  };

  public func deserializeUser(encodedData : Blob) : async ?User {
    let decodedUser : ?User = from_candid(encodedData);

    switch decodedUser {
      case (?user) {
        Debug.print("User data deserialized successfully.");
        return ?user;
      };
      case null {
        Debug.print("Deserialization failed: Invalid blob or type mismatch.");
        return null;
      };
    };
  };
}
```

## Resources

For more detailed information on Candid, refer to:

- [What is Candid?](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/candid-concepts)
- [Using Candid](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid)
- [Candid Specification](https://internetcomputer.org/docs/references/candid-ref)
