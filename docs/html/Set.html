<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/core/Set.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/core/Set.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#coreset" id="toc-coreset">core/Set</a>
<ul>
<li><a href="#type-set" id="toc-type-set">Type <code>Set</code></a></li>
<li><a href="#function-topure" id="toc-function-topure">Function
<code>toPure</code></a></li>
<li><a href="#function-frompure" id="toc-function-frompure">Function
<code>fromPure</code></a></li>
<li><a href="#function-fromarray" id="toc-function-fromarray">Function
<code>fromArray</code></a></li>
<li><a href="#function-clone" id="toc-function-clone">Function
<code>clone</code></a></li>
<li><a href="#function-empty" id="toc-function-empty">Function
<code>empty</code></a></li>
<li><a href="#function-singleton" id="toc-function-singleton">Function
<code>singleton</code></a></li>
<li><a href="#function-clear" id="toc-function-clear">Function
<code>clear</code></a></li>
<li><a href="#function-isempty" id="toc-function-isempty">Function
<code>isEmpty</code></a></li>
<li><a href="#function-size" id="toc-function-size">Function
<code>size</code></a></li>
<li><a href="#function-equal" id="toc-function-equal">Function
<code>equal</code></a></li>
<li><a href="#function-contains" id="toc-function-contains">Function
<code>contains</code></a></li>
<li><a href="#function-add" id="toc-function-add">Function
<code>add</code></a></li>
<li><a href="#function-insert" id="toc-function-insert">Function
<code>insert</code></a></li>
<li><a href="#function-remove" id="toc-function-remove">Function
<code>remove</code></a></li>
<li><a href="#function-delete" id="toc-function-delete">Function
<code>delete</code></a></li>
<li><a href="#function-max" id="toc-function-max">Function
<code>max</code></a></li>
<li><a href="#function-min" id="toc-function-min">Function
<code>min</code></a></li>
<li><a href="#function-toarray" id="toc-function-toarray">Function
<code>toArray</code></a></li>
<li><a href="#function-values" id="toc-function-values">Function
<code>values</code></a></li>
<li><a href="#function-valuesfrom" id="toc-function-valuesfrom">Function
<code>valuesFrom</code></a></li>
<li><a href="#function-reversevalues"
id="toc-function-reversevalues">Function
<code>reverseValues</code></a></li>
<li><a href="#function-reversevaluesfrom"
id="toc-function-reversevaluesfrom">Function
<code>reverseValuesFrom</code></a></li>
<li><a href="#function-fromiter" id="toc-function-fromiter">Function
<code>fromIter</code></a></li>
<li><a href="#function-toset" id="toc-function-toset">Function
<code>toSet</code></a></li>
<li><a href="#function-issubset" id="toc-function-issubset">Function
<code>isSubset</code></a></li>
<li><a href="#function-union" id="toc-function-union">Function
<code>union</code></a></li>
<li><a href="#function-intersection"
id="toc-function-intersection">Function
<code>intersection</code></a></li>
<li><a href="#function-difference" id="toc-function-difference">Function
<code>difference</code></a></li>
<li><a href="#function-addall" id="toc-function-addall">Function
<code>addAll</code></a></li>
<li><a href="#function-deleteall" id="toc-function-deleteall">Function
<code>deleteAll</code></a></li>
<li><a href="#function-insertall" id="toc-function-insertall">Function
<code>insertAll</code></a></li>
<li><a href="#function-retainall" id="toc-function-retainall">Function
<code>retainAll</code></a></li>
<li><a href="#function-foreach" id="toc-function-foreach">Function
<code>forEach</code></a></li>
<li><a href="#function-filter" id="toc-function-filter">Function
<code>filter</code></a></li>
<li><a href="#function-map" id="toc-function-map">Function
<code>map</code></a></li>
<li><a href="#function-filtermap" id="toc-function-filtermap">Function
<code>filterMap</code></a></li>
<li><a href="#function-foldleft" id="toc-function-foldleft">Function
<code>foldLeft</code></a></li>
<li><a href="#function-foldright" id="toc-function-foldright">Function
<code>foldRight</code></a></li>
<li><a href="#function-join" id="toc-function-join">Function
<code>join</code></a></li>
<li><a href="#function-flatten" id="toc-function-flatten">Function
<code>flatten</code></a></li>
<li><a href="#function-all" id="toc-function-all">Function
<code>all</code></a></li>
<li><a href="#function-any" id="toc-function-any">Function
<code>any</code></a></li>
<li><a href="#function-assertvalid"
id="toc-function-assertvalid">Function <code>assertValid</code></a></li>
<li><a href="#function-totext" id="toc-function-totext">Function
<code>toText</code></a></li>
<li><a href="#function-compare" id="toc-function-compare">Function
<code>compare</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="coreset">core/Set</h1>
<p>Imperative (mutable) sets based on order/comparison of elements. A
set is a collection of elements without duplicates. The set data
structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([3, 1, 2, 3].vals(), Nat.compare);
  assert Set.size(set) == 3;
  assert not Set.contains(set, Nat.compare, 4);
  let diff = Set.difference(set, set, Nat.compare);
  assert Set.isEmpty(diff);
}</code></pre>
<p>These sets are implemented as B-trees with order 32, a balanced
search tree of ordered elements.</p>
<p>Performance:</p>
<ul>
<li>Runtime: <code>O(log(n))</code> worst case cost per insertion,
removal, and retrieval operation.</li>
<li>Space: <code>O(n)</code> for storing the entire tree, where
<code>n</code> denotes the number of elements stored in the set.</li>
</ul>
<h2 id="type-set">Type <code>Set</code></h2>
<pre class="motoko"><code>type Set&lt;T&gt; = Types.Set.Set&lt;T&gt;</code></pre>
<h2 id="function-topure">Function <code>toPure</code></h2>
<pre class="motoko"><code>func toPure&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : PureSet.Set&lt;T&gt;</code></pre>
<p>Convert the mutable set to an immutable, purely functional set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import PureSet &quot;mo:core/pure/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter&lt;Nat&gt;([0, 2, 1].values(), Nat.compare);
  let pureSet = Set.toPure(set, Nat.compare);
  assert Iter.toArray(PureSet.values(pureSet)) == Iter.toArray(Set.values(set));
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>
retained memory plus garbage, see the note below. where <code>n</code>
denotes the number of elements stored in the set and assuming that the
<code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<p>Note: Creates <code>O(n * log(n))</code> temporary objects that will
be collected as garbage. @deprecated M0235</p>
<h2 id="function-frompure">Function <code>fromPure</code></h2>
<pre class="motoko"><code>func fromPure&lt;T&gt;(set : PureSet.Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Convert an immutable, purely functional set to a mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code>import PureSet &quot;mo:core/pure/Set&quot;;
import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let pureSet = PureSet.fromIter([3, 1, 2].values(), Nat.compare);
  let set = Set.fromPure(pureSet, Nat.compare);
  assert Iter.toArray(Set.values(set)) == Iter.toArray(PureSet.values(pureSet));
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>. where
<code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison. @deprecated M0235</p>
<h2 id="function-fromarray">Function <code>fromArray</code></h2>
<pre class="motoko"><code>func fromArray&lt;T&gt;(array : [T], compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<h2 id="function-clone">Function <code>clone</code></h2>
<pre class="motoko"><code>func clone&lt;T&gt;(self : Set&lt;T&gt;) : Set&lt;T&gt;</code></pre>
<p>Create a copy of the mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let originalSet = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let clonedSet = Set.clone(originalSet);
  Set.add(originalSet, Nat.compare, 4);
  assert Set.size(clonedSet) == 3;
  assert Set.size(originalSet) == 4;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(n)</code>. where
<code>n</code> denotes the number of elements stored in the set.</p>
<h2 id="function-empty">Function <code>empty</code></h2>
<pre class="motoko"><code>func empty&lt;T&gt;() : Set&lt;T&gt;</code></pre>
<p>Create a new empty mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  assert Set.size(set) == 0;
}</code></pre>
<p>Runtime: <code>O(1)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-singleton">Function <code>singleton</code></h2>
<pre class="motoko"><code>func singleton&lt;T&gt;(element : T) : Set&lt;T&gt;</code></pre>
<p>Create a new mutable set with a single element.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;

persistent actor {
  let cities = Set.singleton&lt;Text&gt;(&quot;Zurich&quot;);
  assert Set.size(cities) == 1;
}</code></pre>
<p>Runtime: <code>O(1)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-clear">Function <code>clear</code></h2>
<pre class="motoko"><code>func clear&lt;T&gt;(self : Set&lt;T&gt;)</code></pre>
<p>Remove all the elements from the set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Text &quot;mo:core/Text&quot;;

persistent actor {
  let cities = Set.empty&lt;Text&gt;();
  Set.add(cities, Text.compare, &quot;Zurich&quot;);
  Set.add(cities, Text.compare, &quot;San Francisco&quot;);
  Set.add(cities, Text.compare, &quot;London&quot;);
  assert Set.size(cities) == 3;

  Set.clear(cities);
  assert Set.size(cities) == 0;
}</code></pre>
<p>Runtime: <code>O(1)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-isempty">Function <code>isEmpty</code></h2>
<pre class="motoko"><code>func isEmpty&lt;T&gt;(self : Set&lt;T&gt;) : Bool</code></pre>
<p>Determines whether a set is empty.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  assert not Set.isEmpty(set);
  Set.clear(set);
  assert Set.isEmpty(set);
}</code></pre>
<p>Runtime: <code>O(1)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-size">Function <code>size</code></h2>
<pre class="motoko"><code>func size&lt;T&gt;(self : Set&lt;T&gt;) : Nat</code></pre>
<p>Return the number of elements in a set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  assert Set.size(set) == 3;
}</code></pre>
<p>Runtime: <code>O(1)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-equal">Function <code>equal</code></h2>
<pre class="motoko"><code>func equal&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Types.Order)) : Bool</code></pre>
<p>Test whether two imperative sets are equal. Both sets have to be
constructed by the same comparison function.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set1 = Set.fromIter([1, 2].values(), Nat.compare);
  let set2 = Set.fromIter([2, 1].values(), Nat.compare);
  let set3 = Set.fromIter([2, 1, 0].values(), Nat.compare);
  assert Set.equal(set1, set2, Nat.compare);
  assert not Set.equal(set1, set3, Nat.compare);
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code>.</p>
<h2 id="function-contains">Function <code>contains</code></h2>
<pre class="motoko"><code>func contains&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : Bool</code></pre>
<p>Tests whether the set contains the provided element.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  assert Set.contains(set, Nat.compare, 1);
  assert not Set.contains(set, Nat.compare, 4);
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(1)</code>. where
<code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison.</p>
<h2 id="function-add">Function <code>add</code></h2>
<pre class="motoko"><code>func add&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T)</code></pre>
<p>Add a new element to a set. No effect if the element already exists
in the set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  assert Iter.toArray(Set.values(set)) == [1, 2];
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(log(n))</code>. where
<code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison.</p>
<h2 id="function-insert">Function <code>insert</code></h2>
<pre class="motoko"><code>func insert&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : Bool</code></pre>
<p>Insert a new element in the set. Returns true if the element is new,
false if the element was already contained in the set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  assert Set.insert(set, Nat.compare, 2);
  assert Set.insert(set, Nat.compare, 1);
  assert not Set.insert(set, Nat.compare, 2);
  assert Iter.toArray(Set.values(set)) == [1, 2];
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(log(n))</code>. where
<code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison. @deprecated M0235</p>
<h2 id="function-remove">Function <code>remove</code></h2>
<pre class="motoko"><code>func remove&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : ()</code></pre>
<p>Deletes an element from a set. No effect if the element is not
contained in the set.</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([1, 2, 3].values(), Nat.compare);

  Set.remove(set, Nat.compare, 2);
  assert not Set.contains(set, Nat.compare, 2);

  Set.remove(set, Nat.compare, 4);
  assert not Set.contains(set, Nat.compare, 4);

  assert Iter.toArray(Set.values(set)) == [1, 3];
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(log(n))</code>
including garbage, see below. where <code>n</code> denotes the number of
elements stored in the set and assuming that the <code>compare</code>
function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(log(n))</code> objects that will be collected
as garbage.</p>
<h2 id="function-delete">Function <code>delete</code></h2>
<pre class="motoko"><code>func delete&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : Bool</code></pre>
<p>Deletes an element from a set. Returns true if the element was
contained in the set, false if not.</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([1, 2, 3].values(), Nat.compare);

  assert Set.delete(set, Nat.compare, 2);
  assert not Set.contains(set, Nat.compare, 2);

  assert not Set.delete(set, Nat.compare, 4);
  assert not Set.contains(set, Nat.compare, 4);
  assert Iter.toArray(Set.values(set)) == [1, 3];
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(log(n))</code>
including garbage, see below. where <code>n</code> denotes the number of
elements stored in the set and assuming that the <code>compare</code>
function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(log(n))</code> objects that will be collected
as garbage. @deprecated M0235</p>
<h2 id="function-max">Function <code>max</code></h2>
<pre class="motoko"><code>func max&lt;T&gt;(self : Set&lt;T&gt;) : ?T</code></pre>
<p>Retrieves the maximum element from the set. If the set is empty,
returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  assert Set.max(set) == null;
  Set.add(set, Nat.compare, 3);
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  assert Set.max(set) == ?3;
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(1)</code>. where
<code>n</code> denotes the number of elements stored in the set.</p>
<h2 id="function-min">Function <code>min</code></h2>
<pre class="motoko"><code>func min&lt;T&gt;(self : Set&lt;T&gt;) : ?T</code></pre>
<p>Retrieves the minimum element from the set. If the set is empty,
returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  assert Set.min(set) == null;
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
  assert Set.min(set) == ?1;
}</code></pre>
<p>Runtime: <code>O(log(n))</code>. Space: <code>O(1)</code>. where
<code>n</code> denotes the number of elements stored in the set.</p>
<h2 id="function-toarray">Function <code>toArray</code></h2>
<pre class="motoko"><code>func toArray&lt;T&gt;(self : Set&lt;T&gt;) : [T]</code></pre>
<h2 id="function-values">Function <code>values</code></h2>
<pre class="motoko"><code>func values&lt;T&gt;(self : Set&lt;T&gt;) : Types.Iter&lt;T&gt;</code></pre>
<p>Returns an iterator over the elements in the set, traversing the
elements in the ascending order.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([0, 2, 3, 1].values(), Nat.compare);

  var tmp = &quot;&quot;;
  for (number in Set.values(set)) {
     tmp #= &quot; &quot; # Nat.toText(number);
  };
  assert tmp == &quot; 0 1 2 3&quot;;
}</code></pre>
<p>Cost of iteration over all elements: Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below. where
<code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-valuesfrom">Function <code>valuesFrom</code></h2>
<pre class="motoko"><code>func valuesFrom&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : Types.Iter&lt;T&gt;</code></pre>
<p>Returns an iterator over the elements in the set, starting from a
given element in ascending order.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([0, 3, 1].values(), Nat.compare);
  assert Iter.toArray(Set.valuesFrom(set, Nat.compare, 1)) == [1, 3];
  assert Iter.toArray(Set.valuesFrom(set, Nat.compare, 2)) == [3];
}</code></pre>
<p>Cost of iteration over all elements: Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below. where
<code>n</code> denotes the number of key-value entries stored in the
map.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-reversevalues">Function <code>reverseValues</code></h2>
<pre class="motoko"><code>func reverseValues&lt;T&gt;(self : Set&lt;T&gt;) : Types.Iter&lt;T&gt;</code></pre>
<p>Returns an iterator over the elements in the set, traversing the
elements in the descending order.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([0, 2, 3, 1].values(), Nat.compare);

  var tmp = &quot;&quot;;
  for (number in Set.reverseValues(set)) {
     tmp #= &quot; &quot; # Nat.toText(number);
  };
  assert tmp == &quot; 3 2 1 0&quot;;
}</code></pre>
<p>Cost of iteration over all elements: Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below. where
<code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-reversevaluesfrom">Function
<code>reverseValuesFrom</code></h2>
<pre class="motoko"><code>func reverseValuesFrom&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), element : T) : Types.Iter&lt;T&gt;</code></pre>
<p>Returns an iterator over the elements in the set, starting from a
given element in descending order.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([0, 1, 3].values(), Nat.compare);
  assert Iter.toArray(Set.reverseValuesFrom(set, Nat.compare, 0)) == [0];
  assert Iter.toArray(Set.reverseValuesFrom(set, Nat.compare, 2)) == [1, 0];
}</code></pre>
<p>Cost of iteration over all elements: Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below. where
<code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-fromiter">Function <code>fromIter</code></h2>
<pre class="motoko"><code>func fromIter&lt;T&gt;(iter : Types.Iter&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Create a mutable set with the elements obtained from an iterator.
Potential duplicate elements in the iterator are ignored, i.e. multiple
occurrence of an equal element only occur once in the set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter&lt;Nat&gt;([3, 1, 2, 1].values(), Nat.compare);
  assert Iter.toArray(Set.values(set)) == [1, 2, 3];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>. where
<code>n</code> denotes the number of elements returned by the iterator
and assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison.</p>
<h2 id="function-toset">Function <code>toSet</code></h2>
<pre class="motoko"><code>func toSet&lt;T&gt;(self : Types.Iter&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Convert an iterator of elements to a mutable set. Potential duplicate
elements in the iterator are ignored, i.e. multiple occurrence of an
equal element only occur once in the set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  transient let iter = [3, 1, 2, 1].values();

  let set = iter.toSet(Nat.compare);

  assert Iter.toArray(Set.values(set)) == [1, 2, 3];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>. where
<code>n</code> denotes the number of elements returned by the iterator
and assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison.</p>
<h2 id="function-issubset">Function <code>isSubset</code></h2>
<pre class="motoko"><code>func isSubset&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Bool</code></pre>
<p>Test whether <code>set1</code> is a sub-set of <code>set2</code>,
i.e. each element in <code>set1</code> is also contained in
<code>set2</code>. Returns <code>true</code> if both sets are equal.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set1 = Set.fromIter([1, 2].values(), Nat.compare);
  let set2 = Set.fromIter([2, 1, 0].values(), Nat.compare);
  let set3 = Set.fromIter([3, 4].values(), Nat.compare);
  assert Set.isSubset(set1, set2, Nat.compare);
  assert not Set.isSubset(set1, set3, Nat.compare);
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements stored in the sets
<code>set1</code> and <code>set2</code>, respectively, and assuming that
the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-union">Function <code>union</code></h2>
<pre class="motoko"><code>func union&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Returns a new set that is the union of <code>set1</code> and
<code>set2</code>, i.e. a new set that all the elements that exist in at
least on of the two sets. Potential duplicates are ignored, i.e. if the
same element occurs in both <code>set1</code> and <code>set2</code>, it
only occurs once in the returned set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set1 = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let set2 = Set.fromIter([3, 4, 5].values(), Nat.compare);
  let union = Set.union(set1, set2, Nat.compare);
  assert Iter.toArray(Set.values(union)) == [1, 2, 3, 4, 5];
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements stored in the sets
<code>set1</code> and <code>set2</code>, respectively, and assuming that
the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-intersection">Function <code>intersection</code></h2>
<pre class="motoko"><code>func intersection&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Returns a new set that is the intersection of <code>set1</code> and
<code>set2</code>, i.e. a new set that contains all the elements that
exist in both sets.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set1 = Set.fromIter([0, 1, 2].values(), Nat.compare);
  let set2 = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let intersection = Set.intersection(set1, set2, Nat.compare);
  assert Iter.toArray(Set.values(intersection)) == [1, 2];
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements stored in the sets
<code>set1</code> and <code>set2</code>, respectively, and assuming that
the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-difference">Function <code>difference</code></h2>
<pre class="motoko"><code>func difference&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Returns a new set that is the difference between <code>set1</code>
and <code>set2</code> (<code>set1</code> minus <code>set2</code>), i.e.
a new set that contains all the elements of <code>set1</code> that do
not exist in <code>set2</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set1 = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let set2 = Set.fromIter([3, 4, 5].values(), Nat.compare);
  let difference = Set.difference(set1, set2, Nat.compare);
  assert Iter.toArray(Set.values(difference)) == [1, 2];
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements stored in the sets
<code>set1</code> and <code>set2</code>, respectively, and assuming that
the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-addall">Function <code>addAll</code></h2>
<pre class="motoko"><code>func addAll&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), iter : Types.Iter&lt;T&gt;)</code></pre>
<p>Adds all elements from <code>iter</code> to the specified
<code>set</code>. This is equivalent to <code>Set.union()</code> but
modifies the set in place.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([1, 2, 3].values(), Nat.compare);
  Set.addAll(set, Nat.compare, [3, 4, 5].values());
  assert Iter.toArray(Set.values(set)) == [1, 2, 3, 4, 5];
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements in <code>set</code> and
<code>iter</code>, respectively, and assuming that the
<code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-deleteall">Function <code>deleteAll</code></h2>
<pre class="motoko"><code>func deleteAll&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), iter : Types.Iter&lt;T&gt;) : Bool</code></pre>
<p>Deletes all values in <code>iter</code> from the specified
<code>set</code>. Returns <code>true</code> if any value was present in
the set, otherwise false. The return value indicates whether the size of
the set has changed.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([0, 1, 2].values(), Nat.compare);
  assert Set.deleteAll(set, Nat.compare, [0, 2].values());
  assert Iter.toArray(Set.values(set)) == [1];
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements in <code>set</code> and
<code>iter</code>, respectively, and assuming that the
<code>compare</code> function implements an <code>O(1)</code>
comparison. @deprecated M0235</p>
<h2 id="function-insertall">Function <code>insertAll</code></h2>
<pre class="motoko"><code>func insertAll&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), iter : Types.Iter&lt;T&gt;) : Bool</code></pre>
<p>Inserts all values in <code>iter</code> into <code>set</code>.
Returns true if any value was not contained in the original set,
otherwise false. The return value indicates whether the size of the set
has changed.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([0, 1, 2].values(), Nat.compare);
  assert Set.insertAll(set, Nat.compare, [0, 2, 3].values());
  assert Iter.toArray(Set.values(set)) == [0, 1, 2, 3];
  assert not Set.insertAll(set, Nat.compare, [0, 1, 2].values()); // no change
}</code></pre>
<p>Runtime: <code>O(m * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>m</code>
and <code>n</code> denote the number of elements in <code>set</code> and
<code>iter</code>, respectively, and assuming that the
<code>compare</code> function implements an <code>O(1)</code>
comparison. @deprecated M0235</p>
<h2 id="function-retainall">Function <code>retainAll</code></h2>
<pre class="motoko"><code>func retainAll&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), predicate : T -&gt; Bool) : Bool</code></pre>
<p>Removes all values in <code>set</code> that do not satisfy the given
predicate. Returns <code>true</code> if and only if the size of the set
has changed. Modifies the set in place.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set = Set.fromIter([3, 1, 2].values(), Nat.compare);

  let sizeChanged = Set.retainAll&lt;Nat&gt;(set, Nat.compare, func n { n % 2 == 0 });
  assert Iter.toArray(Set.values(set)) == [2];
  assert sizeChanged;
}</code></pre>
<h2 id="function-foreach">Function <code>forEach</code></h2>
<pre class="motoko"><code>func forEach&lt;T&gt;(self : Set&lt;T&gt;, operation : T -&gt; ())</code></pre>
<p>Apply an operation on each element contained in the set. The
operation is applied in ascending order of the elements.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let numbers = Set.fromIter([0, 3, 1, 2].values(), Nat.compare);

  var tmp = &quot;&quot;;
  Set.forEach&lt;Nat&gt;(numbers, func (element) {
    tmp #= &quot; &quot; # Nat.toText(element)
  });
  assert tmp == &quot; 0 1 2 3&quot;;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-filter">Function <code>filter</code></h2>
<pre class="motoko"><code>func filter&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order), criterion : T -&gt; Bool) : Set&lt;T&gt;</code></pre>
<p>Filter elements in a new set. Create a copy of the mutable set that
only contains the elements that fulfil the criterion function.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let numbers = Set.fromIter([0, 3, 1, 2].values(), Nat.compare);

  let evenNumbers = Set.filter&lt;Nat&gt;(numbers, Nat.compare, func (number) {
    number % 2 == 0
  });
  assert Iter.toArray(Set.values(evenNumbers)) == [0, 2];
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(n)</code>. where
<code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an
<code>O(1)</code> comparison.</p>
<h2 id="function-map">Function <code>map</code></h2>
<pre class="motoko"><code>func map&lt;T1, T2&gt;(self : Set&lt;T1&gt;, compare : (implicit : (T2, T2) -&gt; Order.Order), project : T1 -&gt; T2) : Set&lt;T2&gt;</code></pre>
<p>Project all elements of the set in a new set. Apply a mapping
function to each element in the set and collect the mapped elements in a
new mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Text &quot;mo:core/Text&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let numbers = Set.fromIter([3, 1, 2].values(), Nat.compare);

  let textNumbers =
    Set.map&lt;Nat, Text&gt;(numbers, Text.compare, Nat.toText);
  assert Iter.toArray(Set.values(textNumbers)) == [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>
retained memory plus garbage, see below. where <code>n</code> denotes
the number of elements stored in the set and assuming that the
<code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-filtermap">Function <code>filterMap</code></h2>
<pre class="motoko"><code>func filterMap&lt;T1, T2&gt;(self : Set&lt;T1&gt;, compare : (implicit : (T2, T2) -&gt; Order.Order), project : T1 -&gt; ?T2) : Set&lt;T2&gt;</code></pre>
<p>Filter all elements in the set by also applying a projection to the
elements. Apply a mapping function <code>project</code> to all elements
in the set and collect all elements, for which the function returns a
non-null new element. Collect all non-discarded new elements in a new
mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Text &quot;mo:core/Text&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let numbers = Set.fromIter([3, 0, 2, 1].values(), Nat.compare);

  let evenTextNumbers = Set.filterMap&lt;Nat, Text&gt;(numbers, Text.compare, func (number) {
    if (number % 2 == 0) {
       ?Nat.toText(number)
    } else {
       null // discard odd numbers
    }
  });
  assert Iter.toArray(Set.values(evenTextNumbers)) == [&quot;0&quot;, &quot;2&quot;];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(n)</code>
retained memory plus garbage, see below. where <code>n</code> denotes
the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-foldleft">Function <code>foldLeft</code></h2>
<pre class="motoko"><code>func foldLeft&lt;T, A&gt;(self : Set&lt;T&gt;, base : A, combine : (A, T) -&gt; A) : A</code></pre>
<p>Iterate all elements in ascending order, and accumulate the elements
by applying the combine function, starting from a base value.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([0, 3, 2, 1].values(), Nat.compare);

  let text = Set.foldLeft&lt;Nat, Text&gt;(
     set,
     &quot;&quot;,
     func (accumulator, element) {
       accumulator # &quot; &quot; # Nat.toText(element)
     }
  );
  assert text == &quot; 0 1 2 3&quot;;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-foldright">Function <code>foldRight</code></h2>
<pre class="motoko"><code>func foldRight&lt;T, A&gt;(self : Set&lt;T&gt;, base : A, combine : (T, A) -&gt; A) : A</code></pre>
<p>Iterate all elements in descending order, and accumulate the elements
by applying the combine function, starting from a base value.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([0, 3, 2, 1].values(), Nat.compare);

  let text = Set.foldRight&lt;Nat, Text&gt;(
     set,
     &quot;&quot;,
     func (element, accumulator) {
        accumulator # &quot; &quot; # Nat.toText(element)
     }
  );
  assert text == &quot; 3 2 1 0&quot;;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-join">Function <code>join</code></h2>
<pre class="motoko"><code>func join&lt;T&gt;(setIterator : Types.Iter&lt;Set&lt;T&gt;&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Construct the union of a series of sets, i.e. all elements of each
set are included in the result set. Any duplicates are ignored, i.e. if
an element occurs in several of the iterated sets, it only occurs once
in the result set.</p>
<p>Assumes all sets are ordered by <code>compare</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  let set1 = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let set2 = Set.fromIter([3, 4, 5].values(), Nat.compare);
  let set3 = Set.fromIter([5, 6, 7].values(), Nat.compare);
  let combined = Set.join([set1, set2, set3].values(), Nat.compare);
  assert Iter.toArray(Set.values(combined)) == [1, 2, 3, 4, 5, 6, 7];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>n</code>
denotes the number of elements stored in the iterated sets, and assuming
that the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-flatten">Function <code>flatten</code></h2>
<pre class="motoko"><code>func flatten&lt;T&gt;(self : Set&lt;Set&lt;T&gt;&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Set&lt;T&gt;</code></pre>
<p>Construct the union of a set of element sets, i.e. all elements of
each element set are included in the result set. Any duplicates are
ignored, i.e. if the same element occurs in multiple element sets, it
only occurs once in the result set.</p>
<p>Assumes all sets are ordered by <code>compare</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;
import Order &quot;mo:core/Order&quot;;
import Iter &quot;mo:core/Iter&quot;;

persistent actor {
  func setCompare(first: Set.Set&lt;Nat&gt;, second: Set.Set&lt;Nat&gt;) : Order.Order {
     Set.compare(first, second, Nat.compare)
  };

  let set1 = Set.fromIter([1, 2, 3].values(), Nat.compare);
  let set2 = Set.fromIter([3, 4, 5].values(), Nat.compare);
  let set3 = Set.fromIter([5, 6, 7].values(), Nat.compare);
  let setOfSets = Set.fromIter([set1, set2, set3].values(), setCompare);
  let flatSet = Set.flatten(setOfSets, Nat.compare);
  assert Iter.toArray(Set.values(flatSet)) == [1, 2, 3, 4, 5, 6, 7];
}</code></pre>
<p>Runtime: <code>O(n * log(n))</code>. Space: <code>O(1)</code>
retained memory plus garbage, see the note below. where <code>n</code>
denotes the number of elements stored in all the sub-sets, and assuming
that the <code>compare</code> function implements an <code>O(1)</code>
comparison.</p>
<h2 id="function-all">Function <code>all</code></h2>
<pre class="motoko"><code>func all&lt;T&gt;(self : Set&lt;T&gt;, predicate : T -&gt; Bool) : Bool</code></pre>
<p>Check whether all elements in the set satisfy a predicate, i.e. the
<code>predicate</code> function returns <code>true</code> for all
elements in the set. Returns <code>true</code> for an empty set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter&lt;Nat&gt;([0, 3, 1, 2].values(), Nat.compare);

  let belowTen = Set.all&lt;Nat&gt;(set, func (number) {
    number &lt; 10
  });
  assert belowTen;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-any">Function <code>any</code></h2>
<pre class="motoko"><code>func any&lt;T&gt;(self : Set&lt;T&gt;, predicate : T -&gt; Bool) : Bool</code></pre>
<p>Check whether at least one element in the set satisfies a predicate,
i.e. the <code>predicate</code> function returns <code>true</code> for
at least one element in the set. Returns <code>false</code> for an empty
set.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter&lt;Nat&gt;([0, 3, 1, 2].values(), Nat.compare);

  let aboveTen = Set.any&lt;Nat&gt;(set, func (number) {
    number &gt; 10
  });
  assert not aboveTen;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-assertvalid">Function <code>assertValid</code></h2>
<pre class="motoko"><code>func assertValid&lt;T&gt;(self : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order))</code></pre>
<p>Internal sanity check function. Can be used to check that elements
have been inserted with a consistent comparison function. Traps if the
internal set structure is invalid. @deprecated M0235</p>
<h2 id="function-totext">Function <code>toText</code></h2>
<pre class="motoko"><code>func toText&lt;T&gt;(self : Set&lt;T&gt;, toText : (implicit : T -&gt; Text)) : Text</code></pre>
<p>Generate a textual representation of all the elements in the set.
Primarily to be used for testing and debugging. The elements are
formatted according to <code>elementFormat</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter&lt;Nat&gt;([0, 3, 1, 2].values(), Nat.compare);

  assert Set.toText(set, Nat.toText) == &quot;Set{0, 1, 2, 3}&quot;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(n)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set and assuming that <code>elementFormat</code>
has runtime and space costs of <code>O(1)</code>.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
<h2 id="function-compare">Function <code>compare</code></h2>
<pre class="motoko"><code>func compare&lt;T&gt;(self : Set&lt;T&gt;, other : Set&lt;T&gt;, compare : (implicit : (T, T) -&gt; Order.Order)) : Order.Order</code></pre>
<p>Compare two sets by comparing the elements. Both sets must have been
created by the same comparison function. The two sets are iterated by
the ascending order of their creation and order is determined by the
following rules: Less: <code>set1</code> is less than <code>set2</code>
if:</p>
<ul>
<li>the pairwise iteration hits an element pair <code>element1</code>
and <code>element2</code> where <code>element1</code> is less than
<code>element2</code> and all preceding elements are equal, or,</li>
<li><code>set1</code> is a strict prefix of <code>set2</code>, i.e.
<code>set2</code> has more elements than <code>set1</code> and all
elements of <code>set1</code> occur at the beginning of iteration
<code>set2</code>. Equal: <code>set1</code> and <code>set2</code> have
same series of equal elements by pairwise iteration. Greater:
<code>set1</code> is neither less nor equal <code>set2</code>.</li>
</ul>
<p>Example:</p>
<pre class="motoko"><code>import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set1 = Set.fromIter([0, 1].values(), Nat.compare);
  let set2 = Set.fromIter([0, 2].values(), Nat.compare);

  assert Set.compare(set1, set2, Nat.compare) == #less;
  assert Set.compare(set1, set1, Nat.compare) == #equal;
  assert Set.compare(set2, set1, Nat.compare) == #greater;
}</code></pre>
<p>Runtime: <code>O(n)</code>. Space: <code>O(1)</code> retained memory
plus garbage, see below. where <code>n</code> denotes the number of
elements stored in the set and assuming that <code>compare</code> has
runtime and space costs of <code>O(1)</code>.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be
collected as garbage.</p>
</body>
</html>
