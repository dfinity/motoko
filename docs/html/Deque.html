<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/base/Deque.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/base/Deque.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#basedeque" id="toc-basedeque">base/Deque</a>
<ul>
<li><a href="#type-deque" id="toc-type-deque">Type
<code>Deque</code></a></li>
<li><a href="#function-empty" id="toc-function-empty">Function
<code>empty</code></a></li>
<li><a href="#function-isempty" id="toc-function-isempty">Function
<code>isEmpty</code></a></li>
<li><a href="#function-pushfront" id="toc-function-pushfront">Function
<code>pushFront</code></a></li>
<li><a href="#function-peekfront" id="toc-function-peekfront">Function
<code>peekFront</code></a></li>
<li><a href="#function-popfront" id="toc-function-popfront">Function
<code>popFront</code></a></li>
<li><a href="#function-pushback" id="toc-function-pushback">Function
<code>pushBack</code></a></li>
<li><a href="#function-peekback" id="toc-function-peekback">Function
<code>peekBack</code></a></li>
<li><a href="#function-popback" id="toc-function-popback">Function
<code>popBack</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="basedeque">base/Deque</h1>
<p>Double-ended queue (deque) of a generic element type
<code>T</code>.</p>
<p>The interface of deques is purely functional, not imperative, and
deques are immutable values. In particular, deque operations such as
push and pop do not update their input deque but instead return the
value of the modified deque, alongside any other data. The input deque
is left unchanged.</p>
<p>Examples of use-cases: Queue (FIFO) by using <code>pushBack()</code>
and <code>popFront()</code>. Stack (LIFO) by using
<code>pushFront()</code> and <code>popFront()</code>.</p>
<p>A deque is internally implemented as two lists, a head access list
and a (reversed) tail access list, that are dynamically size-balanced by
splitting.</p>
<p>Construction: Create a new deque with the
<code>empty&lt;T&gt;()</code> function.</p>
<p>:::note Performance characteristics</p>
<p>Push and pop operations have <code>O(1)</code> amortized cost and
<code>O(n)</code> worst-case cost per call. Space usage follows the same
pattern. <code>n</code> denotes the number of elements stored in the
deque. :::</p>
<h2 id="type-deque">Type <code>Deque</code></h2>
<pre class="motoko"><code>type Deque&lt;T&gt; = (List&lt;T&gt;, List&lt;T&gt;)</code></pre>
<p>Double-ended queue (deque) data type.</p>
<h2 id="function-empty">Function <code>empty</code></h2>
<pre class="motoko"><code>func empty&lt;T&gt;() : Deque&lt;T&gt;</code></pre>
<p>Create a new empty deque.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

Deque.empty&lt;Nat&gt;()</code></pre>
<table>
<thead>
<tr>
<th>Runtime</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="function-isempty">Function <code>isEmpty</code></h2>
<pre class="motoko"><code>func isEmpty&lt;T&gt;(deque : Deque&lt;T&gt;) : Bool</code></pre>
<p>Determine whether a deque is empty. Returns true if
<code>deque</code> is empty, otherwise <code>false</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

let deque = Deque.empty&lt;Nat&gt;();
Deque.isEmpty(deque) // =&gt; true</code></pre>
<table>
<thead>
<tr>
<th>Runtime</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="function-pushfront">Function <code>pushFront</code></h2>
<pre class="motoko"><code>func pushFront&lt;T&gt;(deque : Deque&lt;T&gt;, element : T) : Deque&lt;T&gt;</code></pre>
<p>Insert a new element on the front end of a deque. Returns the new
deque with <code>element</code> in the front followed by the elements of
<code>deque</code>.</p>
<p>This may involve dynamic rebalancing of the two, internally used
lists.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

Deque.pushFront(Deque.pushFront(Deque.empty&lt;Nat&gt;(), 2), 1) // deque with elements [1, 2]</code></pre>
<table>
<thead>
<tr>
<th>Runtime (worst)</th>
<th>Runtime (amortized)</th>
<th>Space (worst)</th>
<th>Space (amortized)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<p><code>n</code> denotes the number of elements stored in the
deque.</p>
<h2 id="function-peekfront">Function <code>peekFront</code></h2>
<pre class="motoko"><code>func peekFront&lt;T&gt;(deque : Deque&lt;T&gt;) : ?T</code></pre>
<p>Inspect the optional element on the front end of a deque. Returns
<code>null</code> if <code>deque</code> is empty. Otherwise, the front
element of <code>deque</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

let deque = Deque.pushFront(Deque.pushFront(Deque.empty&lt;Nat&gt;(), 2), 1);
Deque.peekFront(deque) // =&gt; ?1</code></pre>
<table>
<thead>
<tr>
<th>Runtime</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="function-popfront">Function <code>popFront</code></h2>
<pre class="motoko"><code>func popFront&lt;T&gt;(deque : Deque&lt;T&gt;) : ?(T, Deque&lt;T&gt;)</code></pre>
<p>Remove the element on the front end of a deque. Returns
<code>null</code> if <code>deque</code> is empty. Otherwise, it returns
a pair of the first element and a new deque that contains all the
remaining elements of <code>deque</code>.</p>
<p>This may involve dynamic rebalancing of the two, internally used
lists.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;
import Debug &quot;mo:base/Debug&quot;;
let initial = Deque.pushFront(Deque.pushFront(Deque.empty&lt;Nat&gt;(), 2), 1);
// initial deque with elements [1, 2]
let reduced = Deque.popFront(initial);
switch reduced {
  case null {
    Debug.trap &quot;Empty queue impossible&quot;
  };
  case (?result) {
    let removedElement = result.0; // 1
    let reducedDeque = result.1; // deque with element [2].
  }
}</code></pre>
<table>
<thead>
<tr>
<th>Runtime (worst)</th>
<th>Runtime (amortized)</th>
<th>Space (worst)</th>
<th>Space (amortized)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="function-pushback">Function <code>pushBack</code></h2>
<pre class="motoko"><code>func pushBack&lt;T&gt;(deque : Deque&lt;T&gt;, element : T) : Deque&lt;T&gt;</code></pre>
<p>Insert a new element on the back end of a deque. Returns the new
deque with all the elements of <code>deque</code>, followed by
<code>element</code> on the back.</p>
<p>This may involve dynamic rebalancing of the two, internally used
lists.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

Deque.pushBack(Deque.pushBack(Deque.empty&lt;Nat&gt;(), 1), 2) // deque with elements [1, 2]</code></pre>
<table>
<thead>
<tr>
<th>Runtime (worst)</th>
<th>Runtime (amortized)</th>
<th>Space (worst)</th>
<th>Space (amortized)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<p><code>n</code> denotes the number of elements stored in the
deque.</p>
<h2 id="function-peekback">Function <code>peekBack</code></h2>
<pre class="motoko"><code>func peekBack&lt;T&gt;(deque : Deque&lt;T&gt;) : ?T</code></pre>
<p>Inspect the optional element on the back end of a deque. Returns
<code>null</code> if <code>deque</code> is empty. Otherwise, the back
element of <code>deque</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;

let deque = Deque.pushBack(Deque.pushBack(Deque.empty&lt;Nat&gt;(), 1), 2);
Deque.peekBack(deque) // =&gt; ?2</code></pre>
<table>
<thead>
<tr>
<th>Runtime</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<h2 id="function-popback">Function <code>popBack</code></h2>
<pre class="motoko"><code>func popBack&lt;T&gt;(deque : Deque&lt;T&gt;) : ?(Deque&lt;T&gt;, T)</code></pre>
<p>Remove the element on the back end of a deque. Returns
<code>null</code> if <code>deque</code> is empty. Otherwise, it returns
a pair of a new deque that contains the remaining elements of
<code>deque</code> and, as the second pair item, the removed back
element.</p>
<p>This may involve dynamic rebalancing of the two, internally used
lists.</p>
<p>Example:</p>
<pre class="motoko"><code>import Deque &quot;mo:base/Deque&quot;;
import Debug &quot;mo:base/Debug&quot;;

let initial = Deque.pushBack(Deque.pushBack(Deque.empty&lt;Nat&gt;(), 1), 2);
// initial deque with elements [1, 2]
let reduced = Deque.popBack(initial);
switch reduced {
  case null {
    Debug.trap &quot;Empty queue impossible&quot;
  };
  case (?result) {
    let reducedDeque = result.0; // deque with element [1].
    let removedElement = result.1; // 2
  }
}</code></pre>
<table>
<thead>
<tr>
<th>Runtime (worst)</th>
<th>Runtime (amortized)</th>
<th>Space (worst)</th>
<th>Space (amortized)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
</body>
</html>
