<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/core/Float.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/core/Float.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#corefloat" id="toc-corefloat">core/Float</a>
<ul>
<li><a href="#type-float" id="toc-type-float">Type
<code>Float</code></a></li>
<li><a href="#value-pi" id="toc-value-pi">Value <code>pi</code></a></li>
<li><a href="#value-e" id="toc-value-e">Value <code>e</code></a></li>
<li><a href="#function-isnan" id="toc-function-isnan">Function
<code>isNaN</code></a></li>
<li><a href="#function-abs" id="toc-function-abs">Function
<code>abs</code></a></li>
<li><a href="#function-sqrt" id="toc-function-sqrt">Function
<code>sqrt</code></a></li>
<li><a href="#function-ceil" id="toc-function-ceil">Function
<code>ceil</code></a></li>
<li><a href="#function-floor" id="toc-function-floor">Function
<code>floor</code></a></li>
<li><a href="#function-trunc" id="toc-function-trunc">Function
<code>trunc</code></a></li>
<li><a href="#function-nearest" id="toc-function-nearest">Function
<code>nearest</code></a></li>
<li><a href="#function-copysign" id="toc-function-copysign">Function
<code>copySign</code></a></li>
<li><a href="#function-min" id="toc-function-min">Function
<code>min</code></a></li>
<li><a href="#function-max" id="toc-function-max">Function
<code>max</code></a></li>
<li><a href="#function-sin" id="toc-function-sin">Function
<code>sin</code></a></li>
<li><a href="#function-cos" id="toc-function-cos">Function
<code>cos</code></a></li>
<li><a href="#function-tan" id="toc-function-tan">Function
<code>tan</code></a></li>
<li><a href="#function-arcsin" id="toc-function-arcsin">Function
<code>arcsin</code></a></li>
<li><a href="#function-arccos" id="toc-function-arccos">Function
<code>arccos</code></a></li>
<li><a href="#function-arctan" id="toc-function-arctan">Function
<code>arctan</code></a></li>
<li><a href="#function-arctan2" id="toc-function-arctan2">Function
<code>arctan2</code></a></li>
<li><a href="#function-exp" id="toc-function-exp">Function
<code>exp</code></a></li>
<li><a href="#function-log" id="toc-function-log">Function
<code>log</code></a></li>
<li><a href="#function-format" id="toc-function-format">Function
<code>format</code></a></li>
<li><a href="#function-totext" id="toc-function-totext">Function
<code>toText</code></a></li>
<li><a href="#function-toint64" id="toc-function-toint64">Function
<code>toInt64</code></a></li>
<li><a href="#function-fromint64" id="toc-function-fromint64">Function
<code>fromInt64</code></a></li>
<li><a href="#function-toint" id="toc-function-toint">Function
<code>toInt</code></a></li>
<li><a href="#function-fromint" id="toc-function-fromint">Function
<code>fromInt</code></a></li>
<li><a href="#function-equal" id="toc-function-equal">Function
<code>equal</code></a></li>
<li><a href="#function-notequal" id="toc-function-notequal">Function
<code>notEqual</code></a></li>
<li><a href="#function-less" id="toc-function-less">Function
<code>less</code></a></li>
<li><a href="#function-lessorequal"
id="toc-function-lessorequal">Function <code>lessOrEqual</code></a></li>
<li><a href="#function-greater" id="toc-function-greater">Function
<code>greater</code></a></li>
<li><a href="#function-greaterorequal"
id="toc-function-greaterorequal">Function
<code>greaterOrEqual</code></a></li>
<li><a href="#function-compare" id="toc-function-compare">Function
<code>compare</code></a></li>
<li><a href="#function-neg" id="toc-function-neg">Function
<code>neg</code></a></li>
<li><a href="#function-add" id="toc-function-add">Function
<code>add</code></a></li>
<li><a href="#function-sub" id="toc-function-sub">Function
<code>sub</code></a></li>
<li><a href="#function-mul" id="toc-function-mul">Function
<code>mul</code></a></li>
<li><a href="#function-div" id="toc-function-div">Function
<code>div</code></a></li>
<li><a href="#function-rem" id="toc-function-rem">Function
<code>rem</code></a></li>
<li><a href="#function-pow" id="toc-function-pow">Function
<code>pow</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="corefloat">core/Float</h1>
<p>Double precision (64-bit) floating-point numbers in IEEE 754
representation.</p>
<p>This module contains common floating-point constants and utility
functions.</p>
<pre class="motoko"><code>import Float &quot;mo:core/Float&quot;;</code></pre>
<p>Notation for special values in the documentation below:
<code>+inf</code>: Positive infinity <code>-inf</code>: Negative
infinity <code>NaN</code>: "not a number" (can have different sign bit
values, but <code>NaN != NaN</code> regardless of the sign).</p>
<p>Note: Floating point numbers have limited precision and operations
may inherently result in numerical errors.</p>
<p>Examples of numerical errors:</p>
<pre class="motoko"><code>assert 0.1 + 0.1 + 0.1 != 0.3;</code></pre>
<pre class="motoko"><code>assert not (1e16 + 1.0 != 1e16);</code></pre>
<p>(and many more cases)</p>
<p>Advice:</p>
<ul>
<li><p>Floating point number comparisons by <code>==</code> or
<code>!=</code> are discouraged. Instead, it is better to compare
floating-point numbers with a numerical tolerance, called epsilon.</p>
<p>Example:</p>
<pre class="motoko"><code>import Float &quot;mo:core/Float&quot;;
let x = 0.1 + 0.1 + 0.1;
let y = 0.3;

let epsilon = 1e-6; // This depends on the application case (needs a numerical error analysis).
assert Float.equal(x, y, epsilon);</code></pre></li>
<li><p>For absolute precision, it is recommened to encode the fraction
number as a pair of a Nat for the base and a Nat for the exponent
(decimal point).</p></li>
</ul>
<p>NaN sign:</p>
<ul>
<li>The NaN sign is only applied by <code>abs</code>, <code>neg</code>,
and <code>copySign</code>. Other operations can have an arbitrary sign
bit for NaN results.</li>
</ul>
<h2 id="type-float">Type <code>Float</code></h2>
<pre class="motoko"><code>type Float = Prim.Types.Float</code></pre>
<p>64-bit floating point number type.</p>
<h2 id="value-pi">Value <code>pi</code></h2>
<pre class="motoko"><code>let pi : Float</code></pre>
<p>Ratio of the circumference of a circle to its diameter. Note: Limited
precision.</p>
<h2 id="value-e">Value <code>e</code></h2>
<pre class="motoko"><code>let e : Float</code></pre>
<p>Base of the natural logarithm. Note: Limited precision.</p>
<h2 id="function-isnan">Function <code>isNaN</code></h2>
<pre class="motoko"><code>func isNaN(self : Float) : Bool</code></pre>
<p>Determines whether the <code>number</code> is a <code>NaN</code>
("not a number" in the floating point representation). Notes:</p>
<ul>
<li>Equality test of <code>NaN</code> with itself or another number is
always <code>false</code>.</li>
<li>There exist many internal <code>NaN</code> value representations,
such as positive and negative NaN, signalling and quiet NaNs, each with
many different bit representations.</li>
</ul>
<p>Example:</p>
<pre class="motoko"><code>assert Float.isNaN(0.0/0.0);</code></pre>
<h2 id="function-abs">Function <code>abs</code></h2>
<pre class="motoko"><code>func abs(x : Float) : Float</code></pre>
<p>Returns the absolute value of <code>x</code>.</p>
<p>Special cases:</p>
<pre><code>abs(+inf) =&gt; +inf
abs(-inf) =&gt; +inf
abs(-NaN)  =&gt; +NaN
abs(-0.0) =&gt; 0.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.abs(-1.2), 1.2, epsilon);</code></pre>
<h2 id="function-sqrt">Function <code>sqrt</code></h2>
<pre class="motoko"><code>func sqrt(x : Float) : Float</code></pre>
<p>Returns the square root of <code>x</code>.</p>
<p>Special cases:</p>
<pre><code>sqrt(+inf) =&gt; +inf
sqrt(-0.0) =&gt; -0.0
sqrt(x)    =&gt; NaN if x &lt; 0.0
sqrt(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.sqrt(6.25), 2.5, epsilon);</code></pre>
<h2 id="function-ceil">Function <code>ceil</code></h2>
<pre class="motoko"><code>func ceil(x : Float) : Float</code></pre>
<p>Returns the smallest integral float greater than or equal to
<code>x</code>.</p>
<p>Special cases:</p>
<pre><code>ceil(+inf) =&gt; +inf
ceil(-inf) =&gt; -inf
ceil(NaN)  =&gt; NaN
ceil(0.0)  =&gt; 0.0
ceil(-0.0) =&gt; -0.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.ceil(1.2), 2.0, epsilon);</code></pre>
<h2 id="function-floor">Function <code>floor</code></h2>
<pre class="motoko"><code>func floor(x : Float) : Float</code></pre>
<p>Returns the largest integral float less than or equal to
<code>x</code>.</p>
<p>Special cases:</p>
<pre><code>floor(+inf) =&gt; +inf
floor(-inf) =&gt; -inf
floor(NaN)  =&gt; NaN
floor(0.0)  =&gt; 0.0
floor(-0.0) =&gt; -0.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.floor(1.2), 1.0, epsilon);</code></pre>
<h2 id="function-trunc">Function <code>trunc</code></h2>
<pre class="motoko"><code>func trunc(x : Float) : Float</code></pre>
<p>Returns the nearest integral float not greater in magnitude than
<code>x</code>. This is equivalent to returning <code>x</code> with
truncating its decimal places.</p>
<p>Special cases:</p>
<pre><code>trunc(+inf) =&gt; +inf
trunc(-inf) =&gt; -inf
trunc(NaN)  =&gt; NaN
trunc(0.0)  =&gt; 0.0
trunc(-0.0) =&gt; -0.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.trunc(2.75), 2.0, epsilon);</code></pre>
<h2 id="function-nearest">Function <code>nearest</code></h2>
<pre class="motoko"><code>func nearest(x : Float) : Float</code></pre>
<p>Returns the nearest integral float to <code>x</code>. A decimal place
of exactly .5 is rounded to the nearest even integral float. and rounded
down for <code>x &lt; 0</code></p>
<p>Special cases:</p>
<pre><code>nearest(+inf) =&gt; +inf
nearest(-inf) =&gt; -inf
nearest(NaN)  =&gt; NaN
nearest(0.0)  =&gt; 0.0
nearest(-0.0) =&gt; -0.0
nearest(14.5) =&gt; 14.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.nearest(2.75) == 3.0</code></pre>
<h2 id="function-copysign">Function <code>copySign</code></h2>
<pre class="motoko"><code>func copySign(x : Float, y : Float) : Float</code></pre>
<p>Returns <code>x</code> if <code>x</code> and <code>y</code> have same
sign, otherwise <code>x</code> with negated sign.</p>
<p>The sign bit of zero, infinity, and <code>NaN</code> is
considered.</p>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.copySign(1.2, -2.3), -1.2, epsilon);</code></pre>
<h2 id="function-min">Function <code>min</code></h2>
<pre class="motoko"><code>func min(x : Float, y : Float) : Float</code></pre>
<p>Returns the smaller value of <code>x</code> and <code>y</code>.</p>
<p>Special cases:</p>
<pre><code>min(NaN, y) =&gt; NaN for any Float y
min(x, NaN) =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.min(1.2, -2.3) == -2.3; // with numerical imprecision</code></pre>
<h2 id="function-max">Function <code>max</code></h2>
<pre class="motoko"><code>func max(x : Float, y : Float) : Float</code></pre>
<p>Returns the larger value of <code>x</code> and <code>y</code>.</p>
<p>Special cases:</p>
<pre><code>max(NaN, y) =&gt; NaN for any Float y
max(x, NaN) =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.max(1.2, -2.3) == 1.2;</code></pre>
<h2 id="function-sin">Function <code>sin</code></h2>
<pre class="motoko"><code>func sin(x : Float) : Float</code></pre>
<p>Returns the sine of the radian angle <code>x</code>.</p>
<p>Special cases:</p>
<pre><code>sin(+inf) =&gt; NaN
sin(-inf) =&gt; NaN
sin(NaN) =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.sin(Float.pi / 2), 1.0, epsilon);</code></pre>
<h2 id="function-cos">Function <code>cos</code></h2>
<pre class="motoko"><code>func cos(x : Float) : Float</code></pre>
<p>Returns the cosine of the radian angle <code>x</code>.</p>
<p>Special cases:</p>
<pre><code>cos(+inf) =&gt; NaN
cos(-inf) =&gt; NaN
cos(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.cos(Float.pi / 2), 0.0, epsilon);</code></pre>
<h2 id="function-tan">Function <code>tan</code></h2>
<pre class="motoko"><code>func tan(x : Float) : Float</code></pre>
<p>Returns the tangent of the radian angle <code>x</code>.</p>
<p>Special cases:</p>
<pre><code>tan(+inf) =&gt; NaN
tan(-inf) =&gt; NaN
tan(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.tan(Float.pi / 4), 1.0, epsilon);</code></pre>
<h2 id="function-arcsin">Function <code>arcsin</code></h2>
<pre class="motoko"><code>func arcsin(x : Float) : Float</code></pre>
<p>Returns the arc sine of <code>x</code> in radians.</p>
<p>Special cases:</p>
<pre><code>arcsin(x)   =&gt; NaN if x &gt; 1.0
arcsin(x)   =&gt; NaN if x &lt; -1.0
arcsin(NaN) =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.arcsin(1.0), Float.pi / 2, epsilon);</code></pre>
<h2 id="function-arccos">Function <code>arccos</code></h2>
<pre class="motoko"><code>func arccos(x : Float) : Float</code></pre>
<p>Returns the arc cosine of <code>x</code> in radians.</p>
<p>Special cases:</p>
<pre><code>arccos(x)  =&gt; NaN if x &gt; 1.0
arccos(x)  =&gt; NaN if x &lt; -1.0
arcos(NaN) =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.arccos(1.0), 0.0, epsilon);</code></pre>
<h2 id="function-arctan">Function <code>arctan</code></h2>
<pre class="motoko"><code>func arctan(x : Float) : Float</code></pre>
<p>Returns the arc tangent of <code>x</code> in radians.</p>
<p>Special cases:</p>
<pre><code>arctan(+inf) =&gt; pi / 2
arctan(-inf) =&gt; -pi / 2
arctan(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.arctan(1.0), Float.pi / 4, epsilon);</code></pre>
<h2 id="function-arctan2">Function <code>arctan2</code></h2>
<pre class="motoko"><code>func arctan2(x : Float, y : Float) : Float</code></pre>
<p>Given <code>(y,x)</code>, returns the arc tangent in radians of
<code>y/x</code> based on the signs of both values to determine the
correct quadrant.</p>
<p>Special cases:</p>
<pre><code>arctan2(0.0, 0.0)   =&gt; 0.0
arctan2(-0.0, 0.0)  =&gt; -0.0
arctan2(0.0, -0.0)  =&gt; pi
arctan2(-0.0, -0.0) =&gt; -pi
arctan2(+inf, +inf) =&gt; pi / 4
arctan2(+inf, -inf) =&gt; 3 * pi / 4
arctan2(-inf, +inf) =&gt; -pi / 4
arctan2(-inf, -inf) =&gt; -3 * pi / 4
arctan2(NaN, x)     =&gt; NaN for any Float x
arctan2(y, NaN)     =&gt; NaN for any Float y</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let sqrt2over2 = Float.sqrt(2) / 2;
assert Float.arctan2(sqrt2over2, sqrt2over2) == Float.pi / 4;</code></pre>
<h2 id="function-exp">Function <code>exp</code></h2>
<pre class="motoko"><code>func exp(x : Float) : Float</code></pre>
<p>Returns the value of <code>e</code> raised to the <code>x</code>-th
power.</p>
<p>Special cases:</p>
<pre><code>exp(+inf) =&gt; +inf
exp(-inf) =&gt; 0.0
exp(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.exp(1.0), Float.e, epsilon);</code></pre>
<h2 id="function-log">Function <code>log</code></h2>
<pre class="motoko"><code>func log(x : Float) : Float</code></pre>
<p>Returns the natural logarithm (base-<code>e</code>) of
<code>x</code>.</p>
<p>Special cases:</p>
<pre><code>log(0.0)  =&gt; -inf
log(-0.0) =&gt; -inf
log(x)    =&gt; NaN if x &lt; 0.0
log(+inf) =&gt; +inf
log(NaN)  =&gt; NaN</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.log(Float.e), 1.0, epsilon);</code></pre>
<h2 id="function-format">Function <code>format</code></h2>
<pre class="motoko"><code>func format(self : Float, fmt : {#fix : Nat8; #exp : Nat8; #gen : Nat8; #exact}) : Text</code></pre>
<p>Formatting. <code>format(fmt, x)</code> formats <code>x</code> to
<code>Text</code> according to the formatting directive
<code>fmt</code>, which can take one of the following forms:</p>
<ul>
<li><code>#fix prec</code> as fixed-point format with <code>prec</code>
digits</li>
<li><code>#exp prec</code> as exponential format with <code>prec</code>
digits</li>
<li><code>#gen prec</code> as generic format with <code>prec</code>
digits</li>
<li><code>#exact</code> as exact format that can be decoded without
loss.</li>
</ul>
<p><code>-0.0</code> is formatted with negative sign bit. Positive
infinity is formatted as "inf". Negative infinity is formatted as
"-inf".</p>
<p>The numerical precision and the text format can vary between Motoko
versions and runtime configuration. Moreover, <code>NaN</code> can be
printed differently, i.e. "NaN" or "nan", potentially omitting the
<code>NaN</code> sign.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.format(#exp 3, 123.0) == &quot;1.230e+02&quot;;</code></pre>
<h2 id="function-totext">Function <code>toText</code></h2>
<pre class="motoko"><code>func toText(self : Float) : Text</code></pre>
<p>Conversion to Text. Use <code>format(fmt, x)</code> for more detailed
control.</p>
<p><code>-0.0</code> is formatted with negative sign bit. Positive
infinity is formatted as <code>inf</code>. Negative infinity is
formatted as <code>-inf</code>. <code>NaN</code> is formatted as
<code>NaN</code> or <code>-NaN</code> depending on its sign bit.</p>
<p>The numerical precision and the text format can vary between Motoko
versions and runtime configuration. Moreover, <code>NaN</code> can be
printed differently, i.e. "NaN" or "nan", potentially omitting the
<code>NaN</code> sign.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.toText(1.2) == &quot;1.2&quot;;</code></pre>
<h2 id="function-toint64">Function <code>toInt64</code></h2>
<pre class="motoko"><code>func toInt64(self : Float) : Int64</code></pre>
<p>Conversion to Int64 by truncating Float, equivalent to
<code>toInt64(trunc(f))</code></p>
<p>Traps if the floating point number is larger or smaller than the
representable Int64. Also traps for <code>inf</code>, <code>-inf</code>,
and <code>NaN</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.toInt64(-12.3) == -12;</code></pre>
<h2 id="function-fromint64">Function <code>fromInt64</code></h2>
<pre class="motoko"><code>func fromInt64(x : Int64) : Float</code></pre>
<p>Conversion from Int64.</p>
<p>Note: The floating point number may be imprecise for large or small
Int64.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.fromInt64(-42) == -42.0;</code></pre>
<h2 id="function-toint">Function <code>toInt</code></h2>
<pre class="motoko"><code>func toInt(self : Float) : Int</code></pre>
<p>Conversion to Int.</p>
<p>Traps for <code>inf</code>, <code>-inf</code>, and
<code>NaN</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.toInt(1.2e6) == +1_200_000;</code></pre>
<h2 id="function-fromint">Function <code>fromInt</code></h2>
<pre class="motoko"><code>func fromInt(x : Int) : Float</code></pre>
<p>Conversion from Int. May result in <code>Inf</code>.</p>
<p>Note: The floating point number may be imprecise for large or small
Int values. Returns <code>inf</code> if the integer is greater than the
maximum floating point number. Returns <code>-inf</code> if the integer
is less than the minimum floating point number.</p>
<p>Example:</p>
<pre class="motoko"><code>assert Float.fromInt(-123) == -123.0;</code></pre>
<p>@deprecated M0235</p>
<h2 id="function-equal">Function <code>equal</code></h2>
<pre class="motoko"><code>func equal(x : Float, y : Float, epsilon : Float) : Bool</code></pre>
<p>Determines whether <code>x</code> is equal to <code>y</code> within
the defined tolerance of <code>epsilon</code>. The <code>epsilon</code>
considers numerical erros, see comment above. Equivalent to
<code>Float.abs(x - y) &lt;= epsilon</code> for a non-negative
epsilon.</p>
<p>Traps if <code>epsilon</code> is negative or <code>NaN</code>.</p>
<p>Special cases:</p>
<pre><code>equal(+0.0, -0.0, epsilon) =&gt; true for any `epsilon &gt;= 0.0`
equal(-0.0, +0.0, epsilon) =&gt; true for any `epsilon &gt;= 0.0`
equal(+inf, +inf, epsilon) =&gt; true for any `epsilon &gt;= 0.0`
equal(-inf, -inf, epsilon) =&gt; true for any `epsilon &gt;= 0.0`
equal(x, NaN, epsilon)     =&gt; false for any x and `epsilon &gt;= 0.0`
equal(NaN, y, epsilon)     =&gt; false for any y and `epsilon &gt;= 0.0`</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(-12.3, -1.23e1, epsilon);</code></pre>
<h2 id="function-notequal">Function <code>notEqual</code></h2>
<pre class="motoko"><code>func notEqual(x : Float, y : Float, epsilon : Float) : Bool</code></pre>
<p>Determines whether <code>x</code> is not equal to <code>y</code>
within the defined tolerance of <code>epsilon</code>. The
<code>epsilon</code> considers numerical erros, see comment above.
Equivalent to <code>not equal(x, y, epsilon)</code>.</p>
<p>Traps if <code>epsilon</code> is negative or <code>NaN</code>.</p>
<p>Special cases:</p>
<pre><code>notEqual(+0.0, -0.0, epsilon) =&gt; false for any `epsilon &gt;= 0.0`
notEqual(-0.0, +0.0, epsilon) =&gt; false for any `epsilon &gt;= 0.0`
notEqual(+inf, +inf, epsilon) =&gt; false for any `epsilon &gt;= 0.0`
notEqual(-inf, -inf, epsilon) =&gt; false for any `epsilon &gt;= 0.0`
notEqual(x, NaN, epsilon)     =&gt; true for any x and `epsilon &gt;= 0.0`
notEqual(NaN, y, epsilon)     =&gt; true for any y and `epsilon &gt;= 0.0`</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert not Float.notEqual(-12.3, -1.23e1, epsilon);</code></pre>
<h2 id="function-less">Function <code>less</code></h2>
<pre class="motoko"><code>func less(x : Float, y : Float) : Bool</code></pre>
<p>Returns <code>x &lt; y</code>.</p>
<p>Special cases:</p>
<pre><code>less(+0.0, -0.0) =&gt; false
less(-0.0, +0.0) =&gt; false
less(NaN, y)     =&gt; false for any Float y
less(x, NaN)     =&gt; false for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.less(Float.e, Float.pi);</code></pre>
<h2 id="function-lessorequal">Function <code>lessOrEqual</code></h2>
<pre class="motoko"><code>func lessOrEqual(x : Float, y : Float) : Bool</code></pre>
<p>Returns <code>x &lt;= y</code>.</p>
<p>Special cases:</p>
<pre><code>lessOrEqual(+0.0, -0.0) =&gt; true
lessOrEqual(-0.0, +0.0) =&gt; true
lessOrEqual(NaN, y)     =&gt; false for any Float y
lessOrEqual(x, NaN)     =&gt; false for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.lessOrEqual(0.123, 0.1234);</code></pre>
<h2 id="function-greater">Function <code>greater</code></h2>
<pre class="motoko"><code>func greater(x : Float, y : Float) : Bool</code></pre>
<p>Returns <code>x &gt; y</code>.</p>
<p>Special cases:</p>
<pre><code>greater(+0.0, -0.0) =&gt; false
greater(-0.0, +0.0) =&gt; false
greater(NaN, y)     =&gt; false for any Float y
greater(x, NaN)     =&gt; false for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.greater(Float.pi, Float.e);</code></pre>
<h2 id="function-greaterorequal">Function
<code>greaterOrEqual</code></h2>
<pre class="motoko"><code>func greaterOrEqual(x : Float, y : Float) : Bool</code></pre>
<p>Returns <code>x &gt;= y</code>.</p>
<p>Special cases:</p>
<pre><code>greaterOrEqual(+0.0, -0.0) =&gt; true
greaterOrEqual(-0.0, +0.0) =&gt; true
greaterOrEqual(NaN, y)     =&gt; false for any Float y
greaterOrEqual(x, NaN)     =&gt; false for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>assert Float.greaterOrEqual(0.1234, 0.123);</code></pre>
<h2 id="function-compare">Function <code>compare</code></h2>
<pre class="motoko"><code>func compare(x : Float, y : Float) : Order.Order</code></pre>
<p>Defines a total order of <code>x</code> and <code>y</code> for use in
sorting.</p>
<p>Note: Using this operation to determine equality or inequality is
discouraged for two reasons:</p>
<ul>
<li>It does not consider numerical errors, see comment above. Use
<code>equal(x, y, espilon)</code> or
<code>notEqual(x, y, epsilon)</code> to test for equality or inequality,
respectively.</li>
<li><code>NaN</code> are here considered equal if their sign matches,
which is different to the standard equality by <code>==</code> or when
using <code>equal()</code> or <code>notEqual()</code>.</li>
</ul>
<p>Total order:</p>
<ul>
<li>negative NaN (no distinction between signalling and quiet negative
NaN)</li>
<li>negative infinity</li>
<li>negative numbers (including negative subnormal numbers in standard
order)</li>
<li>negative zero (<code>-0.0</code>)</li>
<li>positive zero (<code>+0.0</code>)</li>
<li>positive numbers (including positive subnormal numbers in standard
order)</li>
<li>positive infinity</li>
<li>positive NaN (no distinction between signalling and quiet positive
NaN)</li>
</ul>
<p>Example:</p>
<pre class="motoko"><code>assert Float.compare(0.123, 0.1234) == #less;</code></pre>
<h2 id="function-neg">Function <code>neg</code></h2>
<pre class="motoko"><code>func neg(x : Float) : Float</code></pre>
<p>Returns the negation of <code>x</code>, <code>-x</code> .</p>
<p>Changes the sign bit for infinity.</p>
<p>Special cases:</p>
<pre><code>neg(+inf) =&gt; -inf
neg(-inf) =&gt; +inf
neg(+NaN) =&gt; -NaN
neg(-NaN) =&gt; +NaN
neg(+0.0) =&gt; -0.0
neg(-0.0) =&gt; +0.0</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.neg(1.23), -1.23, epsilon);</code></pre>
<h2 id="function-add">Function <code>add</code></h2>
<pre class="motoko"><code>func add(x : Float, y : Float) : Float</code></pre>
<p>Returns the sum of <code>x</code> and <code>y</code>,
<code>x + y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>add(+inf, y)    =&gt; +inf if y is any Float except -inf and NaN
add(-inf, y)    =&gt; -inf if y is any Float except +inf and NaN
add(+inf, -inf) =&gt; NaN
add(NaN, y)     =&gt; NaN for any Float y</code></pre>
<p>The same cases apply commutatively, i.e. for
<code>add(y, x)</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.add(1.23, 0.123), 1.353, epsilon);</code></pre>
<h2 id="function-sub">Function <code>sub</code></h2>
<pre class="motoko"><code>func sub(x : Float, y : Float) : Float</code></pre>
<p>Returns the difference of <code>x</code> and <code>y</code>,
<code>x - y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>sub(+inf, y)    =&gt; +inf if y is any Float except +inf or NaN
sub(-inf, y)    =&gt; -inf if y is any Float except -inf and NaN
sub(x, +inf)    =&gt; -inf if x is any Float except +inf and NaN
sub(x, -inf)    =&gt; +inf if x is any Float except -inf and NaN
sub(+inf, +inf) =&gt; NaN
sub(-inf, -inf) =&gt; NaN
sub(NaN, y)     =&gt; NaN for any Float y
sub(x, NaN)     =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.sub(1.23, 0.123), 1.107, epsilon);</code></pre>
<h2 id="function-mul">Function <code>mul</code></h2>
<pre class="motoko"><code>func mul(x : Float, y : Float) : Float</code></pre>
<p>Returns the product of <code>x</code> and <code>y</code>,
<code>x * y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>mul(+inf, y) =&gt; +inf if y &gt; 0.0
mul(-inf, y) =&gt; -inf if y &gt; 0.0
mul(+inf, y) =&gt; -inf if y &lt; 0.0
mul(-inf, y) =&gt; +inf if y &lt; 0.0
mul(+inf, 0.0) =&gt; NaN
mul(-inf, 0.0) =&gt; NaN
mul(NaN, y) =&gt; NaN for any Float y</code></pre>
<p>The same cases apply commutatively, i.e. for
<code>mul(y, x)</code>.</p>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.mul(1.23, 1e2), 123.0, epsilon);</code></pre>
<h2 id="function-div">Function <code>div</code></h2>
<pre class="motoko"><code>func div(x : Float, y : Float) : Float</code></pre>
<p>Returns the division of <code>x</code> by <code>y</code>,
<code>x / y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>div(0.0, 0.0) =&gt; NaN
div(x, 0.0)   =&gt; +inf for x &gt; 0.0
div(x, 0.0)   =&gt; -inf for x &lt; 0.0
div(x, +inf)  =&gt; 0.0 for any x except +inf, -inf, and NaN
div(x, -inf)  =&gt; 0.0 for any x except +inf, -inf, and NaN
div(+inf, y)  =&gt; +inf if y &gt;= 0.0
div(+inf, y)  =&gt; -inf if y &lt; 0.0
div(-inf, y)  =&gt; -inf if y &gt;= 0.0
div(-inf, y)  =&gt; +inf if y &lt; 0.0
div(NaN, y)   =&gt; NaN for any Float y
div(x, NaN)   =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.div(1.23, 1e2), 0.0123, epsilon);</code></pre>
<h2 id="function-rem">Function <code>rem</code></h2>
<pre class="motoko"><code>func rem(x : Float, y : Float) : Float</code></pre>
<p>Returns the floating point division remainder <code>x % y</code>,
which is defined as <code>x - trunc(x / y) * y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>rem(0.0, 0.0) =&gt; NaN
rem(x, y)     =&gt; +inf if sign(x) == sign(y) for any x and y not being +inf, -inf, or NaN
rem(x, y)     =&gt; -inf if sign(x) != sign(y) for any x and y not being +inf, -inf, or NaN
rem(x, +inf)  =&gt; x for any x except +inf, -inf, and NaN
rem(x, -inf)  =&gt; x for any x except +inf, -inf, and NaN
rem(+inf, y)  =&gt; NaN for any Float y
rem(-inf, y)  =&gt; NaN for any Float y
rem(NaN, y)   =&gt; NaN for any Float y
rem(x, NaN)   =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.rem(7.2, 2.3), 0.3, epsilon);</code></pre>
<h2 id="function-pow">Function <code>pow</code></h2>
<pre class="motoko"><code>func pow(x : Float, y : Float) : Float</code></pre>
<p>Returns <code>x</code> to the power of <code>y</code>,
<code>x ** y</code>.</p>
<p>Note: Numerical errors may occur, see comment above.</p>
<p>Special cases:</p>
<pre><code>pow(+inf, y)    =&gt; +inf for any y &gt; 0.0 including +inf
pow(+inf, 0.0)  =&gt; 1.0
pow(+inf, y)    =&gt; 0.0 for any y &lt; 0.0 including -inf
pow(x, +inf)    =&gt; +inf if x &gt; 0.0 or x &lt; 0.0
pow(0.0, +inf)  =&gt; 0.0
pow(x, -inf)    =&gt; 0.0 if x &gt; 0.0 or x &lt; 0.0
pow(0.0, -inf)  =&gt; +inf
pow(x, y)       =&gt; NaN if x &lt; 0.0 and y is a non-integral Float
pow(-inf, y)    =&gt; +inf if y &gt; 0.0 and y is a non-integral or an even integral Float
pow(-inf, y)    =&gt; -inf if y &gt; 0.0 and y is an odd integral Float
pow(-inf, 0.0)  =&gt; 1.0
pow(-inf, y)    =&gt; 0.0 if y &lt; 0.0
pow(-inf, +inf) =&gt; +inf
pow(-inf, -inf) =&gt; 1.0
pow(NaN, y)     =&gt; NaN if y != 0.0
pow(NaN, 0.0)   =&gt; 1.0
pow(x, NaN)     =&gt; NaN for any Float x</code></pre>
<p>Example:</p>
<pre class="motoko"><code>let epsilon = 1e-6;
assert Float.equal(Float.pow(2.5, 2.0), 6.25, epsilon);</code></pre>
</body>
</html>
