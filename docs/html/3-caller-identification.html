<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/icp-features/3-caller-identification.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/icp-features/3-caller-identification.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#caller-identification"
id="toc-caller-identification">Caller identification</a>
<ul>
<li><a href="#adding-access-control"
id="toc-adding-access-control">Adding access control</a></li>
<li><a href="#recording-principals"
id="toc-recording-principals">Recording principals</a></li>
</ul></li>
</ul>
</nav>
<h1 id="caller-identification">Caller identification</h1>
<p>On ICP, every user and canister has a unique
<strong>principal</strong> identifier. When a canister receives a
message, such as a function call, the principal identifying the caller
of the function is included in the message.</p>
<p>The caller’s principal is provided by the network, not the user or
canister. A principal cannot be forged or spoofed by a malicious
user.</p>
<p>Motoko’s <code>shared</code> keyword is used to declare a shared
function. Shared functions support a simple form of caller
identification that can be used to inspect incoming messages and
implement access control based on the caller's principal. The shared
function can also declare an optional parameter of type
<code>{caller : Principal}</code>.</p>
<p>For example, when a shared function is called by a user or another
canister, the caller's principal can be captured with
<code>msg.caller</code>:</p>
<pre class="motoko"><code>shared(msg) func inc() : async () {
  // ... msg.caller ...
}</code></pre>
<p>In this example, the shared function <code>inc()</code> specifies a
<code>msg</code> parameter, a record, and the <code>msg.caller</code>
accesses the principal field of <code>msg</code>.</p>
<p>To access the caller of an actor class constructor, you use the same
syntax on the actor class declaration:</p>
<pre class="motoko"><code>shared(msg) persistent actor class Counter(init : Nat) {
  // ... msg.caller ...
}</code></pre>
<h2 id="adding-access-control">Adding access control</h2>
<p>Access control can be added to an application by recording a caller's
principal and then introducing control rules, such as a list of allowed
principals that are permitted to call the function. If the caller's
principal is not within the list, their call to the function will be
rejected.</p>
<p>For example, if you have an actor called <code>Counter</code>, you
can record the principal that installed the actor by binding it to an
<code>owner</code> variable. Then, you can implement a check that
verifies that the caller of each method the actor exposes is equal to
the principal stored in <code>owner</code>:</p>
<pre class="motoko"><code></code></pre>
<p>In this example, the <code>assert (owner == msg.caller)</code>
expression causes the functions <code>inc()</code> and
<code>bump()</code> to trap if the call is unauthorized, preventing any
modification of the <code>count</code> variable. However, the
<code>read()</code> function permits any caller.</p>
<p>The argument to <code>shared</code> is just a pattern. You can
rewrite the above to use pattern matching:</p>
<pre class="motoko"><code></code></pre>
<p>:::note</p>
<p>Simple actor declarations do not let you access their installer. If
you need access to the installer of an actor, rewrite the actor
declaration as a zero-argument actor class instead.</p>
<pre class="motoko"><code>shared(msg) actor class InstallerAware() {
  let installer = msg.caller; // This is the principal of the installer

  public func whoInstalled() : async Principal {
    installer
  };
}</code></pre>
<p>:::</p>
<h2 id="recording-principals">Recording principals</h2>
<p>Principals support equality, ordering, and hashing, so you can
efficiently store principals in containers for functions such as
maintaining an allow or deny list. More operations on principals are
available in the <a href="../core/Principal">principal</a> core
module.</p>
<p>The data type of <code>Principal</code> in Motoko supports equality,
ordering, and hashing. <code>Principal</code>s both sharable and stable,
meaning you can compare them for equality directly.</p>
<p>Below is an example of how you can record a function's caller
<code>Principal</code>s in a set and check if a caller is already in the
set:</p>
<pre class="motoko"><code></code></pre>
</body>
</html>
