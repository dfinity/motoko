<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="AssocList.html">AssocList</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="Buffer.html">Buffer</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Deque.html">Deque</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="ExperimentalCycles.html">ExperimentalCycles</a></li></li><li><li><a href="ExperimentalInternetComputer.html">ExperimentalInternetComputer</a></li></li><li><li><a href="ExperimentalStableMemory.html">ExperimentalStableMemory</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Hash.html">Hash</a></li></li><li><li><a href="HashMap.html">HashMap</a></li></li><li><li><a href="Heap.html">Heap</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="IterType.html">IterType</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="None.html">None</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="OrderedMap.html">OrderedMap</a></li></li><li><li><a href="OrderedSet.html">OrderedSet</a></li></li><li><li><a href="Prelude.html">Prelude</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="RBTree.html">RBTree</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Region.html">Region</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Timer.html">Timer</a></li></li><li><li><a href="Trie.html">Trie</a></li></li><li><li><a href="TrieMap.html">TrieMap</a></li></li><li><li><a href="TrieSet.html">TrieSet</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.HashMap">HashMap</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#mapFilter">mapFilter</a></li></li></ul></nav><div class="documentation"><h1>HashMap</h1><p>Class <code>HashMap&lt;K, V&gt;</code> provides a hashmap from keys of type <code>K</code> to values of type <code>V</code>.
The class is parameterized by the key's equality and hash functions, and an initial capacity.
However, the underlying allocation occurs only upon the first insertion.</p>
<p>Internally, the map is backed by an array of <code>AssocList</code> (buckets).
The array doubles in size when the expected bucket list size grows beyond a fixed threshold.</p>
<p>:::warning Performance considerations</p>
<p>Certain operations, such as <code>put</code>, are amortized <code>O(1)</code> but can run in worst-case <code>O(size)</code> time.
These worst cases may exceed the cycle limit per message on large maps.
This analysis assumes that the hash function distributes keys uniformly.
Use caution when growing large maps and ensure good hash functions are used.</p>
<p>:::</p>
<p>:::note Non-amortized alternative</p>
<p>For maps without amortization, see <code>TrieMap</code>.
:::</p>
<p>:::info Constructor note</p>
<p>The <code>initCapacity</code> argument sets the initial number of buckets.
All runtime and space complexities assume that the equality and hash functions run in <code>O(1)</code> time and space.</p>
<p>:::</p>
<p>Example:</p>
<pre><code>motoko name=initialize
import HashMap &quot;mo:base/HashMap&quot;;
import Text &quot;mo:base/Text&quot;;

let map = HashMap.HashMap&lt;Text, Nat&gt;(5, Text.equal, Text.hash);</code></pre>

<p>| Runtime   | Space     |
|-----------|-----------|
| <code>O(1)</code> | <code>O(1)</code> |</p>
<div class="declaration"><h4 class="class-declaration" id="type.HashMap"><span class="keyword">class </span><span class="classname">HashMap</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">initCapacity</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">keyEq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">keyHash</span> : <span class="type">K</span> -&gt; <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a><br/>)</h4><div class="declaration"><h4 class="function" id="HashMap.size"><code><span class="keyword">public func </span><span class="fnname">size</span>() : <span class="type">Nat</span></code></h4><p><p>Returns the current number of key-value entries in the map.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.size() // =&gt; 0</code></pre>

<p>| Runtime   | Space     |
|-----------|-----------|
| <code>O(1)</code> | <code>O(1)</code> |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.get"><code><span class="keyword">public func </span><span class="fnname">get</span>(<span class="parameter">key</span> : <span class="type">K</span>) : (<span class="parameter">value</span> : ?<span class="type">V</span>)</code></h4><p><p>Returns the value assocaited with key <code>key</code> if present and <code>null</code> otherwise.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key&quot;, 3);
map.get(&quot;key&quot;) // =&gt; ?3</code></pre>

<p>| Runtime(worst) | Runtime(amortized) |  Space |
|----------------------------|--------------------|---------------------------|
| <code>O(size)</code>                     | <code>O(1)</code>          | <code>O(1)</code>                    |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<span class="parameter">key</span> : <span class="type">K</span>, <span class="parameter">value</span> : <span class="type">V</span>)</code></h4><p><p>Insert the value <code>value</code> with key <code>key</code>. Overwrites any existing entry with key <code>key</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key&quot;, 3);
map.get(&quot;key&quot;) // =&gt; ?3</code></pre>

<p>| Runtime(amortized) | Runtime(worst) | Space (amortized) | Space(worst)
|----------------------------|--------------------|---------------------------|------------------|
| <code>O(1)</code>                     | <code>O(size)</code>          | <code>O(1)</code>                    | <code>O(size)</code>        |
:::note Initial allocation</p>
<p>This operation triggers the allocation of the underlying array if it is the first entry in the map.
:::</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.replace"><code><span class="keyword">public func </span><span class="fnname">replace</span>(<span class="parameter">key</span> : <span class="type">K</span>, <span class="parameter">value</span> : <span class="type">V</span>) : (<span class="parameter">oldValue</span> : ?<span class="type">V</span>)</code></h4><p><p>Insert the value <code>value</code> with key <code>key</code>. Returns the previous value
associated with key <code>key</code> or <code>null</code> if no such value exists.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key&quot;, 3);
ignore map.replace(&quot;key&quot;, 2); // =&gt; ?3
map.get(&quot;key&quot;) // =&gt; ?2</code></pre>

<p>| Expected Amortized Runtime | Worst Case Runtime | Expected Amortized Space | Worst Case Space |
|----------------------------|--------------------|---------------------------|------------------|
| <code>O(1)</code>                     | <code>O(size)</code>          | <code>O(1)</code>                    | <code>O(size)</code>        |</p>
<p>:::note Initial allocation</p>
<p>This operation triggers the allocation of the underlying array if it is the first entry in the map.
:::</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>(<span class="parameter">key</span> : <span class="type">K</span>)</code></h4><p><p>Deletes the entry with the key <code>key</code>. Has no effect if <code>key</code> is not
present in the map.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key&quot;, 3);
map.delete(&quot;key&quot;);
map.get(&quot;key&quot;); // =&gt; null</code></pre>

<p>| Expected Runtime | Worst Case Runtime | Expected Space | Worst Case Space |
|------------------|--------------------|----------------|------------------|
| <code>O(1)</code>           | <code>O(size)</code>          | <code>O(1)</code>         | <code>O(size)</code>        |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>(<span class="parameter">key</span> : <span class="type">K</span>) : (<span class="parameter">oldValue</span> : ?<span class="type">V</span>)</code></h4><p><p>Deletes the entry with the key <code>key</code>. Returns the previous value
associated with key <code>key</code> or <code>null</code> if no such value exists.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key&quot;, 3);
map.remove(&quot;key&quot;); // =&gt; ?3</code></pre>

<p>| Expected Runtime | Worst Case Runtime | Expected Space | Worst Case Space |
|------------------|--------------------|----------------|------------------|
| <code>O(1)</code>           | <code>O(size)</code>          | <code>O(1)</code>         | <code>O(size)</code>        |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.keys"><code><span class="keyword">public func </span><span class="fnname">keys</span>() : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">K</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the keys of the map.
Iterator provides a single method <code>next()</code>, which returns
keys in no specific order, or <code>null</code> when out of keys to iterate over.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

var keys = &quot;&quot;;
for (key in map.keys()) {
  keys := key # &quot; &quot; # keys
};
keys // =&gt; &quot;key3 key2 key1 &quot;</code></pre>

<p>Cost of iteration over all keys:</p>
<p>| Runtime   | Space     |
|-----------|-----------|
| <code>O(size)</code> | <code>O(1)</code> |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.vals"><code><span class="keyword">public func </span><span class="fnname">vals</span>() : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">V</span>&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the values of the map.
Iterator provides a single method <code>next()</code>, which returns
values in no specific order, or <code>null</code> when out of values to iterate over.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

var sum = 0;
for (value in map.vals()) {
  sum += value;
};
sum // =&gt; 6</code></pre>

<p>| Runtime   | Space     |
|-----------|-----------|
| <code>O(size)</code> | <code>O(1)</code> |</p>
</p></div><div class="declaration"><h4 class="function" id="HashMap.entries"><code><span class="keyword">public func </span><span class="fnname">entries</span>() : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the key-value pairs in the map.
Iterator provides a single method <code>next()</code>, which returns
pairs in no specific order, or <code>null</code> when out of pairs to iterate over.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

var pairs = &quot;&quot;;
for ((key, value) in map.entries()) {
  pairs := &quot;(&quot; # key # &quot;, &quot; # Nat.toText(value) # &quot;) &quot; # pairs
};
pairs // =&gt; &quot;(key3, 3) (key2, 2) (key1, 1)&quot;</code></pre>

<p>Cost of iteration over all pairs:</p>
<p>| Runtime   | Space     |
|-----------|-----------|
| <code>O(size)</code> | <code>O(1)</code> |</p>
</p></div><p></p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keyEq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">keyHash</span> : <span class="type">K</span> -&gt; <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a><br/>) : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Returns a copy of <code>map</code>, initializing the copy with the provided equality
and hash functions.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

let map2 = HashMap.clone(map, Text.equal, Text.hash);
map2.get(&quot;key1&quot;) // =&gt; ?1</code></pre>

<p>| Runtime(expected) | Runtime(worst) |  Space(expected) | Space(worst) |
|------------------|--------------------|----------------|------------------|
| <code>O(size)</code>        | <code>O(size * size)</code>   | <code>O(size)</code>      | <code>O(size)</code>        |</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">iter</span> : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;, <br/>  <span class="parameter">initCapacity</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">keyEq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">keyHash</span> : <span class="type">K</span> -&gt; <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a><br/>) : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Returns a new map, containing all entries given by the iterator <code>iter</code>.
The new map is initialized with the provided initial capacity, equality,
and hash functions.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
let entries = [(&quot;key3&quot;, 3), (&quot;key2&quot;, 2), (&quot;key1&quot;, 1)];
let iter = entries.vals();

let map2 = HashMap.fromIter&lt;Text, Nat&gt;(iter, entries.size(), Text.equal, Text.hash);
map2.get(&quot;key1&quot;) // =&gt; ?1</code></pre>

<p>| Runtime(expected) | Runtime(worst) |  Space(expected) | Space(worst) |
|------------------|--------------------|----------------|------------------|
| <code>O(size)</code>        | <code>O(size * size)</code>   | <code>O(size)</code>      | <code>O(size)</code>        |</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">K</span>, <span class="type">V1</span>, <span class="type">V2</span>&gt;(<br/>  <span class="parameter">hashMap</span> : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V1</span>&gt;, <br/>  <span class="parameter">keyEq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">keyHash</span> : <span class="type">K</span> -&gt; <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a>, <br/>  <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V1</span>) -&gt; <span class="type">V2</span><br/>) : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V2</span>&gt;</code></h4><p><p>Creates a new map by applying <code>f</code> to each entry in <code>hashMap</code>. Each entry
<code>(k, v)</code> in the old map is transformed into a new entry <code>(k, v2)</code>, where
the new value <code>v2</code> is created by applying <code>f</code> to <code>(k, v)</code>.</p>
<pre><code>motoko include=initialize
map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

let map2 = HashMap.map&lt;Text, Nat, Nat&gt;(map, Text.equal, Text.hash, func (k, v) = v * 2);
map2.get(&quot;key2&quot;) // =&gt; ?4</code></pre>

<p>Expected Runtime: O(size), Worst Case Runtime: O(size * size)</p>
<p>| Runtime(expected) | Runtime(worst) |  Space(expected) | Space(worst) |
|------------------|--------------------|----------------|------------------|
| <code>O(size)</code>        | <code>O(size * size)</code>   | <code>O(size)</code>      | <code>O(size)</code>        |</p>
</p></div><div class="declaration"><h4 class="function" id="mapFilter"><code><span class="keyword">public func </span><span class="fnname">mapFilter</span>&lt;<span class="type">K</span>, <span class="type">V1</span>, <span class="type">V2</span>&gt;(<br/>  <span class="parameter">hashMap</span> : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V1</span>&gt;, <br/>  <span class="parameter">keyEq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">keyHash</span> : <span class="type">K</span> -&gt; <a href="Hash.html#type.Hash"><span class="type">Hash.Hash</span></a>, <br/>  <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V1</span>) -&gt; ?<span class="type">V2</span><br/>) : <a href="#type.HashMap"><span class="type">HashMap</span></a>&lt;<span class="type">K</span>, <span class="type">V2</span>&gt;</code></h4><p><p>Creates a new map by applying <code>f</code> to each entry in <code>hashMap</code>. For each entry
<code>(k, v)</code> in the old map, if <code>f</code> evaluates to <code>null</code>, the entry is discarded.
Otherwise, the entry is transformed into a new entry <code>(k, v2)</code>, where
the new value <code>v2</code> is the result of applying <code>f</code> to <code>(k, v)</code>.</p>
<pre><code>motoko include=initialize
map.put(&quot;key1&quot;, 1);
map.put(&quot;key2&quot;, 2);
map.put(&quot;key3&quot;, 3);

let map2 =
  HashMap.mapFilter&lt;Text, Nat, Nat&gt;(
    map,
    Text.equal,
    Text.hash,
    func (k, v) = if (v == 2) { null } else { ?(v * 2)}
);
map2.get(&quot;key3&quot;) // =&gt; ?6</code></pre>

<p>| Runtime(expected) | Runtime(worst) |  Space(expected) | Space(worst) |
|------------------|--------------------|----------------|------------------|
| <code>O(size)</code>        | <code>O(size * size)</code>   | <code>O(size)</code>      | <code>O(size)</code>        |</p>
</p></div></div></body></html>